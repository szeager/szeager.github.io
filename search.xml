<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/27/hello-world/"/>
      <url>/2023/02/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【go体系课】第二节课作业</title>
      <link href="/2021/05/20/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/"/>
      <url>/2021/05/20/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="必做：channel-⼀⻚中，找出所有红线报错在-runtime-中的位置"><a href="#必做：channel-⼀⻚中，找出所有红线报错在-runtime-中的位置" class="headerlink" title="必做：channel ⼀⻚中，找出所有红线报错在 runtime 中的位置"></a>必做：channel ⼀⻚中，找出所有红线报错在 runtime 中的位置</h3><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/1.png" alt="1"></h4><h4 id="send-on-closed-channel"><a href="#send-on-closed-channel" class="headerlink" title="send on closed channel"></a>send on closed channel</h4><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/2.png" alt="2"></p><h4 id="close-of-closed-channel"><a href="#close-of-closed-channel" class="headerlink" title="close of closed channel"></a>close of closed channel</h4><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/3.png" alt="3"></p><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// close of nil channel</span><br><span class="line">func main() &#123;</span><br><span class="line">var ch chan int</span><br><span class="line">close(ch)</span><br><span class="line">ch &lt;- 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// close of closed channel</span><br><span class="line">func main() &#123;</span><br><span class="line">ch := make(chan int, 1)</span><br><span class="line">ch &lt;- 1</span><br><span class="line">close(ch)</span><br><span class="line">close(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// send on closed channel</span><br><span class="line">func main() &#123;</span><br><span class="line">ch := make(chan int, 1)</span><br><span class="line">ch &lt;- 1</span><br><span class="line">close(ch)</span><br><span class="line">ch &lt;- 2</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="panic-源代码"><a href="#panic-源代码" class="headerlink" title="panic 源代码"></a>panic 源代码</h4><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/4.png" alt="4"></p><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/5.png" alt="5"></p><h3 id="选做-1：修复https-golearn-coding-net-p-gonggongbanji-files-all-DF12中的-test-case"><a href="#选做-1：修复https-golearn-coding-net-p-gonggongbanji-files-all-DF12中的-test-case" class="headerlink" title="选做 1：修复https://golearn.coding.net/p/gonggongbanji/files/all/DF12中的 test case"></a>选做 1：修复<a href="https://golearn.coding.net/p/gonggongbanji/files/all/DF12">https://golearn.coding.net/p/gonggongbanji/files/all/DF12</a>中的 test case</h3><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/6.png" alt="6"></p><h3 id="选做-2：扩展其功能，增加更多的操作符号⽀持-随意发挥"><a href="#选做-2：扩展其功能，增加更多的操作符号⽀持-随意发挥" class="headerlink" title="选做 2：扩展其功能，增加更多的操作符号⽀持(随意发挥)"></a>选做 2：扩展其功能，增加更多的操作符号⽀持(随意发挥)</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【go体系课】第一节课作业</title>
      <link href="/2021/05/17/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/"/>
      <url>/2021/05/17/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="1、部署好本机的-docker-环境，使用-ppt-中的-dockerfile-build-自己的环境"><a href="#1、部署好本机的-docker-环境，使用-ppt-中的-dockerfile-build-自己的环境" class="headerlink" title="1、部署好本机的 docker 环境，使用 ppt 中的 dockerfile build 自己的环境"></a>1、部署好本机的 docker 环境，使用 ppt 中的 dockerfile build 自己的环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  mkdir docker_test</span><br><span class="line">➜  cd docker_test</span><br><span class="line">➜  touch Dockerfile</span><br><span class="line">➜  docker_test ls</span><br><span class="line">Dockerfile</span><br><span class="line">➜  cd docker_test</span><br><span class="line">➜  sudo  docker build -t test .</span><br></pre></td></tr></table></figure><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/1.png" alt="1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  docker_test sudo docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED              SIZE</span><br><span class="line">test          latest    8f7733761a0d   About a minute ago   762MB</span><br><span class="line">hello-world   latest    d1165f221234   2 months ago         13.3kB</span><br><span class="line">centos        latest    300e315adb2f   5 months ago         209MB</span><br><span class="line"></span><br><span class="line">➜  docker_test sudo docker run -it --rm test bash</span><br><span class="line"></span><br><span class="line">[root@32dc92a782a2 code]# touch hello.go</span><br><span class="line">[root@32dc92a782a2 code]# vi hello.go</span><br><span class="line">[root@32dc92a782a2 code]# go build hello.go</span><br><span class="line">[root@32dc92a782a2 code]# ls</span><br><span class="line">bin  dev  etc  hello  hello.gohome  lib  lib64  lost+found  media  mnt  opt  proc  root  runsbin  srv  systmp  usr  var</span><br><span class="line">[root@32dc92a782a2 code]# readelf -h ./hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/2.png" alt="2"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@32dc92a782a2 code]# go build -x hello.go</span><br></pre></td></tr></table></figure><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/3.png" alt="3"></p><h3 id="2、使用-readelf-工具，查看编译后的进程入口地址-amp-在-dlv-调试工具中，使用断点功能找到代码位置"><a href="#2、使用-readelf-工具，查看编译后的进程入口地址-amp-在-dlv-调试工具中，使用断点功能找到代码位置" class="headerlink" title="2、使用 readelf 工具，查看编译后的进程入口地址&amp;在 dlv 调试工具中，使用断点功能找到代码位置"></a>2、使用 readelf 工具，查看编译后的进程入口地址&amp;在 dlv 调试工具中，使用断点功能找到代码位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@1f558add4864 code]# readelf -h hello</span><br><span class="line"></span><br><span class="line">[root@003a3639e337 code]# dlv debug</span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) b *0x455780</span><br><span class="line">Breakpoint 1 set at 0x455780 for runtime.vdsoParseSymbols() /usr/lib/golang/src/runtime/vdso_linux.go:247</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/4.png" alt="4"></p><h3 id="3、使用断点调试功能，查看-Go-的-runtime-的下列函数执行流程"><a href="#3、使用断点调试功能，查看-Go-的-runtime-的下列函数执行流程" class="headerlink" title="3、使用断点调试功能，查看 Go 的 runtime 的下列函数执行流程"></a>3、使用断点调试功能，查看 Go 的 runtime 的下列函数执行流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  go-test dlv debug</span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) breakpoints</span><br><span class="line">Breakpoint runtime-fatal-throw (enabled) at 0x43f700 for runtime.fatalthrow() /usr/local/go/src/runtime/panic.go:1163 (0)</span><br><span class="line">Breakpoint unrecovered-panic (enabled) at 0x43f780 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:1190 (0)</span><br><span class="line">print runtime.curg._panic.arg</span><br><span class="line">(dlv) b main.main</span><br><span class="line">Breakpoint 1 (enabled) set at 0x706018 for main.main() ./main.go:34</span><br><span class="line">(dlv) b runtime.runqget</span><br><span class="line">Breakpoint 2 (enabled) set at 0x44f653 for runtime.runqget() /usr/local/go/src/runtime/proc.go:5895</span><br><span class="line">(dlv) b runtime.globrunqget</span><br><span class="line">Breakpoint 3 (enabled) set at 0x44ec13 for runtime.globrunqget() /usr/local/go/src/runtime/proc.go:5615</span><br><span class="line">(dlv) b runtime.globrunqput</span><br><span class="line">Breakpoint 4 (enabled) set at 0x44eacf for runtime.globrunqput() /usr/local/go/src/runtime/proc.go:5584</span><br><span class="line">(dlv) b runtime.globrunqget</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/5.png" alt="5"></p><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/6.png" alt="6"></p><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/7.png" alt="7"></p><h3 id="4、使用-IDE-查看函数的调用方"><a href="#4、使用-IDE-查看函数的调用方" class="headerlink" title="4、使用 IDE 查看函数的调用方"></a>4、使用 IDE 查看函数的调用方</h3><p><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/8.png" alt="8"><br><img src="/images/yuque/%E3%80%90go%E4%BD%93%E7%B3%BB%E8%AF%BE%E3%80%91%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E4%BD%9C%E4%B8%9A/9.png" alt="9"></p><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虽然按照作业要求操作了一遍</span><br><span class="line">但是实际上不是很懂这个流程要怎么去读懂运用</span><br><span class="line">希望能在接下来的课程里把这些调试用起来</span><br></pre></td></tr></table></figure><p>​</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/chai2010/advanced-go-programming-book/blob/master/ch3-asm/ch3-09-debug.md</span><br></pre></td></tr></table></figure><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes学习笔记</title>
      <link href="/2020/04/13/yuque/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/13/yuque/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>一、概念理论<br>k8s<br>k8s 是一组服务器集群，k8s 所管理的集群节点上的容器</p><p>功能<br>自我修复<br>弹性伸缩:实现根据服务器的并发情况，增加或缩减容器数量<br>自动部署<br>回滚<br>服务发现和负载均衡<br>机密和配置共享管理</p><p>两类节点<br>master node: 主<br>worker node: 工作</p><p>master 节点的组件(程序)<br>apiserver 接收客户端操作 k8s 的指令（增删查改）<br>scheduler 调度-从多个 worker node 节点的组件中选举一个来启动服务<br>controller manager 向 worker 节点的 kubelet 发送指令 （控制后端节点启动 Docker 容器）<br>etcd 数据库<br>分布式键值存储系统。<br>用于保存集群状态数据，比如 Pod,Service 等对象信息</p><p>worker 节点的组件(程序)<br>kubelet 向 docker 发送指令，管理 docker 容器（启动 docker 镜像）<br>kubeproxy   管理 docker 容器的网络</p><p><img src="/images/yuque/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="1"></p><p>核心概念<br>Pod<br>最小部署单元<br>可以有一个或者多个容器的一组容器的集合<br>又称为容器组<br>一个 Pod 中的容器共享网络命名空间<br>是短暂的</p><p>controller: 控制器，控制 pod，启动、停止、删除<br>ReplicaSet<br>Deployment<br>Statefulset<br>DaemonSet<br>Job<br>Cronjob: 定时任务</p><p>Service ：服务–防止 Pod 失联<br>将一组 pod 关联起来，提供一个统一的入口</p><p>Label :   标签<br>一组 Pod 有一个统一的标签<br>servicie 是通过标签和一组 pod 进行关联</p><p>Namespace: 名称空间</p><p>隔离 pod 运行，在逻辑上彼此隔离（默认情况下，pod 是可以相互访问的）<br>为不同的用户提供隔离的 pod 运行环境<br>为开发环境、测试环境、生产环境分别准备不同的名称空间，进行隔离</p><p>二、搭建一个完整的 Kubernetes 集群<br>1、生产环境 K8s 平台规划<br>2、服务器硬件配置推荐<br>3、官方提供三种部署方式<br>4、为 Etcd 和 APIService 自带 SSL 证书<br>5、Etcd 数据库集群部署<br>6、部署 Master 组件<br>7、部署 Node 组件<br>8、部署 k8s 集群网络<br>9、部署 WebUI(DashBoard)<br>10、部署集群内部 DNS 解析服务（CoreDNS）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos7配置k8s</title>
      <link href="/2020/04/07/yuque/Centos7%E9%85%8D%E7%BD%AEk8s/"/>
      <url>/2020/04/07/yuque/Centos7%E9%85%8D%E7%BD%AEk8s/</url>
      
        <content type="html"><![CDATA[<p>环境<br>系统 ：Centos 7 <br>cluster: 一台 master 一台 node</p><p>1、先把 wget 安装上</p><blockquote><p>[root@master01 ~]# yum -y install wget</p></blockquote><p>2、把&#x2F;etc&#x2F;yum.repos.d&#x2F;目录下所有的 repo 文件移动到其他目录，例如 bak&#x2F;，<br>然后下载 Centos-7.repo。【因为添加 K8s 仓库的时候会报错，这步解决了这个问题，把步骤提前】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]# mkdir bak</span><br><span class="line">[root@master01 ~]# mv *.repo bak/</span><br><span class="line">[root@master01 ~]# wget http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">参考：https://blog.csdn.net/kelvin_yin/article/details/86674703</span><br></pre></td></tr></table></figure><p>3、K8s 镜像仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 新增kubernetes源</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">k8仓库部署方法请参考 https://developer.aliyun.com/mirror/kubernetes?spm=a2c6h.13651102.0.0.3e221b11SW3mYV</span><br></pre></td></tr></table></figure><h3 id="更新-yum-缓存"><a href="#更新-yum-缓存" class="headerlink" title="更新 yum 缓存"></a>更新 yum 缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]# yum clean all</span><br><span class="line">[root@master01 ~]# yum makecache</span><br><span class="line">[root@master01 ~]# yum update</span><br><span class="line"></span><br><span class="line">刚才安装docker时遇到问题yum [Errno 256] No more mirrors to try 解决方法：</span><br><span class="line"></span><br><span class="line">1.yum clean all</span><br><span class="line">2.yum makecache</span><br><span class="line">3.yum update</span><br></pre></td></tr></table></figure><h3 id="安装-docker、kubelet、kubeadm、kubecli。"><a href="#安装-docker、kubelet、kubeadm、kubecli。" class="headerlink" title="安装 docker、kubelet、kubeadm、kubecli。"></a>安装 docker、kubelet、kubeadm、kubecli。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]# yum install kubectl kubeadm kubecli -y --nogpgcheck</span><br><span class="line">[root@master01 ~]# yum install docker -y</span><br></pre></td></tr></table></figure><h3 id="安装-docker-底层工具"><a href="#安装-docker-底层工具" class="headerlink" title="安装 docker 底层工具"></a>安装 docker 底层工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]# yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h3 id="设置-Docker-源"><a href="#设置-Docker-源" class="headerlink" title="设置 Docker 源"></a>设置 Docker 源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]# yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">[root@master01 ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo //阿里云yum源</span><br></pre></td></tr></table></figure><h3 id="docker-安装版本查看"><a href="#docker-安装版本查看" class="headerlink" title="docker 安装版本查看"></a>docker 安装版本查看</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]# yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]# yum install docker-ce-18.09.9 docker-ce-cli-18.09.9 containerd.io -y</span><br><span class="line">// 指定安装的docker版本为18.09.9</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]# systemctl start docker</span><br><span class="line">[root@master01 ~]# systemctl enable docker</span><br></pre></td></tr></table></figure><h3 id="linux-命令自动补全"><a href="#linux-命令自动补全" class="headerlink" title="linux 命令自动补全"></a>linux 命令自动补全</h3><h3 id="安装-bash-completion"><a href="#安装-bash-completion" class="headerlink" title="安装 bash-completion"></a>安装 bash-completion</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]# yum -y install bash-completion</span><br></pre></td></tr></table></figure><h3 id="加载-bash-completion"><a href="#加载-bash-completion" class="headerlink" title="加载 bash-completion"></a>加载 bash-completion</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]# source /etc/profile.d/bash_completion.sh</span><br></pre></td></tr></table></figure><p><em>registry.cn-qingdao.aliyuncs.com&#x2F;kubernetes-image</em><br>_<br><a href="https://www.kubernetes.org.cn/6632.html">https://www.kubernetes.org.cn/6632.html</a></p><p><a href="https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/">https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</a> errno</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Window和Centos我都要。</title>
      <link href="/2020/04/05/yuque/Window%E5%92%8CCentos%E6%88%91%E9%83%BD%E8%A6%81%E3%80%82/"/>
      <url>/2020/04/05/yuque/Window%E5%92%8CCentos%E6%88%91%E9%83%BD%E8%A6%81%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h1 id="一、先安装-Windows-系统"><a href="#一、先安装-Windows-系统" class="headerlink" title="一、先安装 Windows 系统"></a>一、先安装 Windows 系统</h1><p>1、制作启动盘<br>2、更改 bios 启动项、选择 U 盘启动<br>3、进入 PE 系统，划分好分区，安装自己下好的 window 系统。</p><h1 id="二、安装-Centos"><a href="#二、安装-Centos" class="headerlink" title="二、安装 Centos"></a>二、安装 Centos</h1><h2 id="1、UltraISO-刻录镜像至-U-盘内"><a href="#1、UltraISO-刻录镜像至-U-盘内" class="headerlink" title="1、UltraISO 刻录镜像至 U 盘内"></a>1、UltraISO 刻录镜像至 U 盘内</h2><p>第一步，打开 CentOS-7-x86_64-DVD-1511.iso 镜像文件；<br>第二步，选择打开的镜像文件，点击菜单栏中的<strong>启动-写入硬盘镜像</strong>；<br>第三步，选择磁盘驱动器（U 盘所在位置），选中写入方式为**USB-HDD+**，点击写入。</p><h2 id="2、准备磁盘空闲区域"><a href="#2、准备磁盘空闲区域" class="headerlink" title="2、准备磁盘空闲区域"></a>2、准备磁盘空闲区域</h2><p>第一步，打开磁盘管理器，<strong>计算机-管理-磁盘管理</strong>；<br>第二步，选择<strong>压缩卷</strong>或者<strong>删除卷</strong>，获取空闲区域。</p><h2 id="3、重启电脑，选择-U-盘启动安装-CentOS-系统"><a href="#3、重启电脑，选择-U-盘启动安装-CentOS-系统" class="headerlink" title="3、重启电脑，选择 U 盘启动安装 CentOS 系统"></a>3、重启电脑，选择 U 盘启动安装 CentOS 系统</h2><h3 id="①、重启电脑，进入-Bios，选择-U-盘启动；"><a href="#①、重启电脑，进入-Bios，选择-U-盘启动；" class="headerlink" title="①、重启电脑，进入 Bios，选择 U 盘启动；"></a>①、重启电脑，进入 Bios，选择 U 盘启动；</h3><h3 id="②、进入安装界面，选择-Install-CentOS7-项，进行安装；"><a href="#②、进入安装界面，选择-Install-CentOS7-项，进行安装；" class="headerlink" title="②、进入安装界面，选择 Install CentOS7 项，进行安装；"></a>②、进入安装界面，选择 Install CentOS7 项，进行安装；</h3><h3 id="③、安装时出现问题【-Warning-dracut-initqueue-timeout-starting-timeout-scripts】"><a href="#③、安装时出现问题【-Warning-dracut-initqueue-timeout-starting-timeout-scripts】" class="headerlink" title="③、安装时出现问题【 Warning: dracut-initqueue timeout - starting timeout scripts】"></a>③、安装时出现问题【 Warning: dracut-initqueue timeout - starting timeout scripts】</h3><h4 id="确认好-CentosU-盘的标签"><a href="#确认好-CentosU-盘的标签" class="headerlink" title="确认好 CentosU 盘的标签"></a>确认好 CentosU 盘的标签</h4><p><img src="/images/yuque/Window%E5%92%8CCentos%E6%88%91%E9%83%BD%E8%A6%81%E3%80%82/1.png" alt="1"></p><h4 id="在安装-CentOS7，【Install-CentOS-7】时，按-Tab-键，进行编辑"><a href="#在安装-CentOS7，【Install-CentOS-7】时，按-Tab-键，进行编辑" class="headerlink" title="在安装 CentOS7，【Install CentOS 7】时，按 Tab 键，进行编辑"></a>在安装 CentOS7，【Install CentOS 7】时，按 Tab 键，进行编辑</h4><p><img src="/images/yuque/Window%E5%92%8CCentos%E6%88%91%E9%83%BD%E8%A6%81%E3%80%82/2.png" alt="2"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">默认是：vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet</span><br><span class="line"></span><br><span class="line">修改成U盘的标签</span><br><span class="line">vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CENTOS\x207\x20x8 quiet</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="④、选择语言（这里选择简体中文），默认最小安装，按自己需求安装，安装的时候可以设置账号和密码"><a href="#④、选择语言（这里选择简体中文），默认最小安装，按自己需求安装，安装的时候可以设置账号和密码" class="headerlink" title="④、选择语言（这里选择简体中文），默认最小安装，按自己需求安装，安装的时候可以设置账号和密码"></a>④、选择语言（这里选择简体中文），默认最小安装，按自己需求安装，安装的时候可以设置账号和密码</h3><h2 id="4、没有网络，ifconfig-command-not-found"><a href="#4、没有网络，ifconfig-command-not-found" class="headerlink" title="4、没有网络，ifconfig command not found"></a>4、没有网络，ifconfig command not found</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、查看网络</span><br><span class="line">root# ip addr</span><br><span class="line"></span><br><span class="line">2、修改网卡配置文件</span><br><span class="line">root# $vim /etc/sysconfig/network-scripts/ifcfg-enxxx</span><br><span class="line">打开文件后ONBOOT为yes</span><br><span class="line"></span><br><span class="line">3、重启网卡</span><br><span class="line">centos6的网卡重启方法：service network restart</span><br><span class="line">centos7的网卡重启方法：systemctl restart network</span><br><span class="line"></span><br><span class="line">4、ifconfig command not found</span><br><span class="line">root# cd /sbin</span><br><span class="line">root# ls | grep &#x27;ifconfig&#x27;</span><br><span class="line">// 没有则说明没有安装。</span><br><span class="line">// 需要进行安装</span><br><span class="line">root# sudo yum installnet-tools</span><br></pre></td></tr></table></figure><p>参考文献：<br><a href="https://blog.csdn.net/yangsong4353/article/details/87876786">https://blog.csdn.net/yangsong4353/article/details/87876786</a><br><a href="https://blog.csdn.net/weixin_34416649/article/details/93367249">https://blog.csdn.net/weixin_34416649&#x2F;article&#x2F;details&#x2F;93367249</a><br><a href="https://www.cnblogs.com/freeweb/p/5213877.html">https://www.cnblogs.com/freeweb/p/5213877.html</a><br><a href="https://blog.csdn.net/mengxiangjia_linxi/article/details/78965103">https://blog.csdn.net/mengxiangjia_linxi&#x2F;article&#x2F;details&#x2F;78965103</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English learning for every day</title>
      <link href="/2020/02/20/yuque/English%20learning%20for%20every%20day/"/>
      <url>/2020/02/20/yuque/English%20learning%20for%20every%20day/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><h2 id="1、新概念英语第一册"><a href="#1、新概念英语第一册" class="headerlink" title="1、新概念英语第一册"></a>1、新概念英语第一册</h2><h3 id="时间：【2020-x2F-02-x2F-20-2020-x2F-03-x2F-29】"><a href="#时间：【2020-x2F-02-x2F-20-2020-x2F-03-x2F-29】" class="headerlink" title="时间：【2020&#x2F;02&#x2F;20 ~ 2020&#x2F;03&#x2F;29】"></a><em>时间：【2020&#x2F;02&#x2F;20 ~ 2020&#x2F;03&#x2F;29】</em></h3><table><thead><tr><th align="center"></th><th align="center">周一</th><th align="center">周二</th><th align="center">周三</th><th align="center">周四</th><th align="center">周五</th><th align="center">周六</th><th align="center">周日</th></tr></thead><tbody><tr><td align="center">第一周</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">[1,2,3,4]</td><td align="center">[5,6,7,8]</td><td align="center">[9,10,11,12]</td><td align="center">[13,14,15,16]</td></tr><tr><td align="center">第二周</td><td align="center">[17,18,19,20]</td><td align="center">复习前二十课</td><td align="center">[21,22,23,24]</td><td align="center">[25,26,27,28]</td><td align="center">[29,30]</td><td align="center">[31,32]</td><td align="center">[33,34]</td></tr><tr><td align="center">第三周</td><td align="center">[35,36]</td><td align="center">[37,38]</td><td align="center">[39,40]</td><td align="center">[41,复习]</td><td align="center">[42,43]</td><td align="center">[44,45]</td><td align="center">[46,47]</td></tr><tr><td align="center">第四周</td><td align="center">[48,49]</td><td align="center">[50,51]</td><td align="center">[52, 53]</td><td align="center">[54,55]</td><td align="center">[56,57]</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">第五周</td><td align="center"></td><td align="center">[复习 42-56]</td><td align="center">[58,59]</td><td align="center">[60,61]</td><td align="center">[62,63]</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">第六周</td><td align="center">[64,65]</td><td align="center">[66,67]</td><td align="center">[68,69]</td><td align="center">[70,71]</td><td align="center">[72]</td><td align="center">总复习</td><td align="center"></td></tr></tbody></table><h3 id="①、新东方教学视频"><a href="#①、新东方教学视频" class="headerlink" title="①、新东方教学视频"></a>①、新东方教学视频</h3><h3 id="②、背单词"><a href="#②、背单词" class="headerlink" title="②、背单词"></a>②、背单词</h3><h3 id="③、课后习题"><a href="#③、课后习题" class="headerlink" title="③、课后习题"></a>③、课后习题</h3><h3 id="④、背诵课文"><a href="#④、背诵课文" class="headerlink" title="④、背诵课文"></a>④、背诵课文</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【自考学习】操作系统</title>
      <link href="/2020/02/01/yuque/%E3%80%90%E8%87%AA%E8%80%83%E5%AD%A6%E4%B9%A0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/02/01/yuque/%E3%80%90%E8%87%AA%E8%80%83%E5%AD%A6%E4%B9%A0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、操作系统概论"><a href="#一、操作系统概论" class="headerlink" title="一、操作系统概论"></a>一、操作系统概论</h1><h2 id="计算机系统的资源："><a href="#计算机系统的资源：" class="headerlink" title="计算机系统的资源："></a>计算机系统的资源：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">硬件资源</span><br><span class="line">软件资源</span><br><span class="line">在计算机系统中，集中为了资源管理功能和控制程序执行功能的一种软件，称为操作系统。</span><br></pre></td></tr></table></figure><h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义:"></a>操作系统的定义:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">定义的解析：</span><br><span class="line"></span><br><span class="line">组织和管理计算机系统中的硬件资源和软件资源。</span><br><span class="line"></span><br><span class="line">有效：指操作系统在管理计算机资源时要考虑到系统运行的效率和利源的利用率。要尽可能提高中央处理器的利用率，让它尽可能少的空转，应该在保证访问效能的前提下尽可能有效地利用其它资源。</span><br><span class="line">比如，减少内存、硬盘资源的浪费</span><br><span class="line"></span><br><span class="line">合理： 指操作系统要公平对待不同的用户程序，保证系统不发生死锁和饥饿的现象。</span><br><span class="line"></span><br><span class="line">方便：指操作系统的人机界面要考虑到用户使用界面和程序接口两个方面的易用性、易学性和易维护性</span><br><span class="line">用户接口：命令、图形界面</span><br><span class="line">  程序接口： windows api， linux 系统调用。（程序员更方便使用程序接口进行编程）</span><br></pre></td></tr></table></figure><h2 id="操作系统的特征："><a href="#操作系统的特征：" class="headerlink" title="操作系统的特征："></a>操作系统的特征：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">并发性</span><br><span class="line">是指计算机系统中同时存在着若干个运行着的程序，从宏观上看，这些程序在同时向前推进。</span><br><span class="line">共享性</span><br><span class="line">操作系统需与多个用户程序共用系统中的各种资源，（CPU、内存、外部设备等）</span><br><span class="line">随机性（异步性）</span><br><span class="line">操作系统不能对所运行的程序的行为以及硬件设备的情况作出任何事先的假定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="操作系统的观点"><a href="#操作系统的观点" class="headerlink" title="操作系统的观点"></a>操作系统的观点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">软件的观点：</span><br><span class="line">操作系统是一个大型系统软件，它是多种功能程序的集合。有外在特性和内在特性。</span><br><span class="line">  外在：接口</span><br><span class="line">    内在：与硬件交互</span><br><span class="line"></span><br><span class="line">资源管理的观点</span><br><span class="line"> 操作系统负责登记谁在使用什么样的资源，系统中还有哪些资源空闲，当前响应了谁对资源的请求，以及回收那些不再使用的资源等。</span><br><span class="line"></span><br><span class="line">进程的观点</span><br><span class="line"> 把操作系统看做由多个可以同时独立运行的程序和一个对这些程序进行协调的核心。</span><br><span class="line"> 侧重于分析系统各部分的并行工作，研究处理各项管理任务的分割以及这些管理任务相互之间的关系。</span><br><span class="line">  比如，竞争资源、进程通信等</span><br><span class="line"></span><br><span class="line">虚拟机的观点</span><br><span class="line">在操作系统的支持下，用户不需要直接使用硬件机器，而是通过操作系统提供的各种手段来控制和使用计算机。</span><br><span class="line"></span><br><span class="line">服务提供者的观点</span><br><span class="line">从用户的角度，站在操作系统之外观察操作系统，认为该服务提供者为用户提供了比裸机功能更强、服务质量更高、更方便灵活的虚拟机。</span><br></pre></td></tr></table></figure><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">进程管理</span><br><span class="line">进程管理的实质：对中央处理器进行管理，或者称为处理器管理。</span><br><span class="line">  多道程序技术：多个程序同时放入内存，如果一个程序因为等待某个条件而不能运行，就把处理器专用权转交给另一个可运行程序。</span><br><span class="line">进行的引入：为了描述多道程序的并发而引入（PCB）</span><br><span class="line">  进程的简单定义: 一个程序的运行过程</span><br><span class="line">  进程管理的内容：进程控制、进程同步、进程间通信、调度。</span><br><span class="line"></span><br><span class="line">存储管理</span><br><span class="line">任务：管理计算机内存的资源</span><br><span class="line">  功能：</span><br><span class="line">  内存的分配与回收：当多个程序共享有限的内存资源时，要考虑如何为多个程序分配有限的内存空间，以及程序运行完毕还需要内存回收。</span><br><span class="line">    存储保护：存储在内存中的多个程序和数据应该彼此隔离、互不侵扰</span><br><span class="line">    内存扩充：将辅助存储器作为内存的扩充空间</span><br><span class="line"></span><br><span class="line">文件管理</span><br><span class="line">任务：有效地支持文件的存储、检索和修改等操作，解决文件的共享、保密和保护问题，以便用户方便、安全地访问文件</span><br><span class="line">  功能：</span><br><span class="line">  文件存储空间的管理</span><br><span class="line">    目录管理</span><br><span class="line">    文件系统的安全性</span><br><span class="line"></span><br><span class="line">设备管理</span><br><span class="line">设备管理的含义</span><br><span class="line">  指计算机系统中除了处理器和内存以外的所有输入、输出设备的管理</span><br><span class="line">  功能</span><br><span class="line">   负责外部设备的分配、启动和故障处理</span><br><span class="line">  采用的技术</span><br><span class="line">  中断技术、通道技术、虚拟设备技术、缓冲技术、尽可能发挥设备和主机的并行能力</span><br><span class="line"></span><br><span class="line">用户接口</span><br><span class="line">从用户观点看，操作系统是用户与计算机之间的接口</span><br><span class="line">任务：为用户提供一个使用系统的良好环境，使用户能有效地组织自己的工作流程，并使整个系统高效地运行。</span><br></pre></td></tr></table></figure><h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><h3 id="Windows-操作系统的体系结构"><a href="#Windows-操作系统的体系结构" class="headerlink" title="Windows 操作系统的体系结构"></a>Windows 操作系统的体系结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内核</span><br><span class="line">功能：线程调度、陷入处理和异常调度、中断处理和调度、多处理器同步、供执行体使用的基本内核对象。</span><br><span class="line">硬件抽象层HAL</span><br><span class="line">系统可移植性的关键部分，为运行在windows操作系统上的硬件平台低级接口，隐藏了各种与硬件有关的细节，如I/O接口等专用的和依赖于计算机平台的函数</span><br><span class="line">执行体</span><br><span class="line">属于内核，以系统函数的形式提供了系统的服务，可通过win32API进行访问</span><br><span class="line">系统进程和系统线程</span><br><span class="line">执行系统代码</span><br></pre></td></tr></table></figure><h3 id="Unix-操作系统的体系结构"><a href="#Unix-操作系统的体系结构" class="headerlink" title="Unix 操作系统的体系结构"></a>Unix 操作系统的体系结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内核层</span><br><span class="line">是操作系统管理和控制中心，常驻内存。</span><br><span class="line">  有两种接口：内核与硬件和接口和内核与shell的接口</span><br><span class="line"></span><br><span class="line">系统层</span><br><span class="line">内核层与应用层之间，供程序员开发调用，包括进程管理、文件管理、中断状态</span><br><span class="line"></span><br><span class="line">应用层</span><br><span class="line">面向用户操作的界面</span><br></pre></td></tr></table></figure><h3 id="Linux-操作系统的体系结构"><a href="#Linux-操作系统的体系结构" class="headerlink" title="Linux 操作系统的体系结构"></a>Linux 操作系统的体系结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内核、shell、文件、系统和应用程序</span><br></pre></td></tr></table></figure><h3 id="Android-操作系统的体系结构"><a href="#Android-操作系统的体系结构" class="headerlink" title="Android 操作系统的体系结构"></a>Android 操作系统的体系结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用程序从，应用框架层，系统运行层，Linux内核层</span><br></pre></td></tr></table></figure><h2 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">手工阶段</span><br><span class="line">监控程序</span><br><span class="line">多道批处理</span><br><span class="line">分时与实时操作系统</span><br><span class="line">Unix通用操作系统</span><br><span class="line">个人计算机操作系统</span><br><span class="line">Android操作系统</span><br></pre></td></tr></table></figure><h2 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h2><h3 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">基本工作方式</span><br><span class="line">用户将作业交给系统操作员，系统操作员在收到作业后，并不立即将作业输入计算机，</span><br><span class="line">  而是收到一定数量的用户作业之后，组成一批作业，再把这批作业输入到计算机中。</span><br><span class="line">  这批作业可在操作系统中形成一个连续的、自动转接的作业流。</span><br><span class="line">  系统操作员然后启动操作系统，系统自动、依次执行每个作业。</span><br><span class="line">  最后由操作员将执行完毕的作业交给用户。</span><br><span class="line"></span><br><span class="line">特点与分类</span><br><span class="line">特点:成批处理，用户不能干预自己作业的运行</span><br><span class="line">  目标：系统资源利用率高，作业吞吐率高。</span><br><span class="line">  分类：简单批处理和多道批处理。</span><br><span class="line"></span><br><span class="line">设计思想：</span><br><span class="line">在监控程序启动之前，操作员有选择地把若干个作业合并成一批作业，将这批作业安装在输入设备上。</span><br><span class="line">  然后启动监控程序，监控程序将自动控制这批作业的执行。</span><br><span class="line">  作业的运行与衔接都由监控程序自动控制，从而有效地提高了作业运行的效率。</span><br><span class="line"></span><br><span class="line">作业控制说明书</span><br><span class="line">作业控制说明书是由作业控制语言编写的一段程序，它通常存储在被处理作业的前面</span><br><span class="line">  作业的运行由作业控制说明书来传递给监控程序，运行过程中，监控程序读入并解释作业说明书，</span><br><span class="line">  以控制各个作业步的执行。</span><br><span class="line"></span><br><span class="line">一般指令和特权指令</span><br><span class="line">操作系统的运行模式：用户模式和特权模式</span><br><span class="line">  处理器的状态：目态和管态</span><br><span class="line">  机器指令：一般指令和特权指令</span><br><span class="line">  系统调用：用户程序不能直接使用特权指令，它们必须向操作系统请求这些功能，这些功能通过系统调用完成。</span><br><span class="line"></span><br><span class="line">系统调用的过程</span><br><span class="line">首先，当系统调用发生时，由中断或异常处理程序，把控制流程转移到监控程序内的一些特定位置处理器模式变成特权模式</span><br><span class="line">  其次，由监控程序执行被请求的功能</span><br><span class="line">  最后，恢复现场，运行模式转变为用户模式，控制权交给用户程序</span><br><span class="line"></span><br><span class="line">SPOOLing技术</span><br><span class="line">是多道程序设计的关键技术之一，也称为假脱机技术</span><br></pre></td></tr></table></figure><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">基本工作方式</span><br><span class="line">在分时系统中，一台主机连接了若干个终端，每个终端可由一个用户使用。用户通过终端交互式地向系统提出命令请求，</span><br><span class="line">  系统接收到用户命令之后，采用时间片轮转方式处理服务请求，并通过交互方式在终端上向用户显示结果。</span><br><span class="line"></span><br><span class="line">特点</span><br><span class="line">多路线</span><br><span class="line">  交互性</span><br><span class="line">  “独占性”</span><br><span class="line">  及时性</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">实时操作系统是指，</span><br><span class="line">使计算机能在规定时间内，及时响应外部事件的请求，同时完成对该事件的处理，并能够控制所有实时设备和实时任务协调一致地工作的操作系统</span><br><span class="line"></span><br><span class="line">目标</span><br><span class="line">在严格时间范围内，对外部请求做出反应，系统具有高可靠性。</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">硬实时系统和软实时系统</span><br><span class="line"></span><br><span class="line">能力</span><br><span class="line">除了多道程序系统的基本能力外，还有以下功能：</span><br><span class="line">  实时时钟管理</span><br><span class="line">    过载防护</span><br><span class="line">    高可靠性</span><br></pre></td></tr></table></figure><h3 id="个人操作系统"><a href="#个人操作系统" class="headerlink" title="个人操作系统"></a>个人操作系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单用户操作系统一次只能支持一个用户程序的运行。单用户操作系统向用户提供联机交互式的工作环境，比如MS-DOS就是一个经典的单用户操作系统。</span><br></pre></td></tr></table></figure><h3 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一种在通常操作系统功能的基础上提供网络通信和网络服务功能的操作系统。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种以计算机网络为基础的，将物理上分布的具有自治功能的数据处理系统或计算机系统互联起来的操作系统。分布式系统中各台计算机无主次之分，系统中若干台计算机可以并行运行同一个程序，分布式操作系统用于管理分布式系统资源。</span><br></pre></td></tr></table></figure><h3 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义</span><br><span class="line">在各种电器、电子和智能机械上，嵌入安装着各种微处理器或微控制芯片</span><br><span class="line">  嵌入式操作系统就是运行在嵌入式芯片环境中，对整个芯片以及它所操作、控制的各种部件装置等资源进行统一协调、调度、指挥和控制的系统软件。</span><br><span class="line"></span><br><span class="line">微型化、实时性、高可靠性</span><br></pre></td></tr></table></figure><h2 id="操作系统设计"><a href="#操作系统设计" class="headerlink" title="操作系统设计"></a>操作系统设计</h2><h3 id="操作系统的设计过程"><a href="#操作系统的设计过程" class="headerlink" title="操作系统的设计过程"></a>操作系统的设计过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">功能设计</span><br><span class="line">确定所设计的操作系统应具备哪些功能以及操作系统的类型，跟目标有关</span><br><span class="line"></span><br><span class="line">算法设计</span><br><span class="line">选择和设计满足系统功能的算法和策略，并分析和估算其效能。</span><br><span class="line"></span><br><span class="line">结构设计</span><br></pre></td></tr></table></figure><h3 id="操作系统的设计目标"><a href="#操作系统的设计目标" class="headerlink" title="操作系统的设计目标"></a>操作系统的设计目标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可靠性</span><br><span class="line">高效性</span><br><span class="line">易维护性</span><br><span class="line">可移植性</span><br><span class="line">安全性</span><br><span class="line">简明性</span><br></pre></td></tr></table></figure><h3 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">操作系统结构研究的目标</span><br><span class="line">系统模块化</span><br><span class="line">模块标准化</span><br><span class="line">通信规范化</span><br><span class="line"></span><br><span class="line">常见的操作系统的结构</span><br><span class="line">整体式结构</span><br><span class="line">  层次式结构</span><br><span class="line">  微内核（客户/服务器）结构</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二、操作系统运行环境"><a href="#二、操作系统运行环境" class="headerlink" title="二、操作系统运行环境"></a>二、操作系统运行环境</h1><h2 id="1、处理器"><a href="#1、处理器" class="headerlink" title="1、处理器"></a>1、处理器</h2><h3 id="①、处理器的构成与基本工作方式"><a href="#①、处理器的构成与基本工作方式" class="headerlink" title="①、处理器的构成与基本工作方式"></a>①、处理器的构成与基本工作方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">处理器一般由运算器、控制器和一系列寄存器以及高速缓存构成</span><br><span class="line">运算器实现算数与逻辑运算</span><br><span class="line">控制器控制程序运行流程</span><br><span class="line">寄存器用于处理器执行指令的过程中暂存数据、地址及指令信息</span><br><span class="line">高速缓存：为CPU和内存提供一个高速的数据缓存区域</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="处理器中的寄存器"><a href="#处理器中的寄存器" class="headerlink" title="处理器中的寄存器"></a>处理器中的寄存器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两类寄存器</span><br><span class="line"> 用户可见寄存器，由编译程序分配，减少程序运行时访问内存的次数</span><br><span class="line">   （一般包括数据寄存器，地址寄存器，条件码寄存器）</span><br></pre></td></tr></table></figure><h4 id="指令执行的基本过程"><a href="#指令执行的基本过程" class="headerlink" title="指令执行的基本过程"></a>指令执行的基本过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">最简单的是两个步骤</span><br><span class="line">读取指令，并将程序计数器的值变成下一条指令的地址</span><br><span class="line">  指令放入指令寄存器中，处理器解释并执行该指令。</span><br><span class="line"></span><br><span class="line">指令分类</span><br><span class="line">访问存储指令、I/O指令、算数逻辑指令、控制转移指令、控制器控制指令</span><br></pre></td></tr></table></figure><h3 id="②、特权指令和非特权指令"><a href="#②、特权指令和非特权指令" class="headerlink" title="②、特权指令和非特权指令"></a>②、特权指令和非特权指令</h3><blockquote><p>在多道程序环境下，指令分为特权指令和非特权指令</p></blockquote><h4 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在操作系统中哪些只能由操作系统使用的指令</span><br><span class="line">不允许一般用户使用</span><br><span class="line">比如：设置程序状态字、启动某设备、设置中断屏蔽字等</span><br></pre></td></tr></table></figure><p>非特权指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普通用户使用的指令</span><br></pre></td></tr></table></figure><h3 id="③、处理器的工作状态"><a href="#③、处理器的工作状态" class="headerlink" title="③、处理器的工作状态"></a>③、处理器的工作状态</h3><h4 id="管态和目态"><a href="#管态和目态" class="headerlink" title="管态和目态"></a>管态和目态</h4><blockquote><p>管态：操作系统管理程序运行时的状态，又称内核态、系统态等，具由较高特权<br>目态：一般用户程序运行时的状态，又称用户态、普通态、具有较低特权</p></blockquote><h4 id="处理器工作状态的转换"><a href="#处理器工作状态的转换" class="headerlink" title="处理器工作状态的转换"></a>处理器工作状态的转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目态到管态的转换：</span><br><span class="line">唯一途径是通过中断。中断响应式交换中断向量，新的中断向量的PSW（程序状态寄存器）的处理器状态标志位管态</span><br><span class="line"></span><br><span class="line">管态到目态的转换：</span><br><span class="line">可通过设置PSW指令、实现从操作系统到用户程序的转换</span><br></pre></td></tr></table></figure><h4 id="限制用户程序执行特权指令"><a href="#限制用户程序执行特权指令" class="headerlink" title="限制用户程序执行特权指令"></a>限制用户程序执行特权指令</h4><blockquote><p>当用户程序执行时，如果取到了一条特权指令，则处理器拒绝执行该指令，并形成一个“非法操作”事件，然后操作系统通知用户程序-程序中有非法指令</p></blockquote><h4 id="程序状态字"><a href="#程序状态字" class="headerlink" title="程序状态字"></a>程序状态字</h4><blockquote><p>为了解决处理器当前工作状态的问题，所有的处理器都由一些特殊寄存器，用以表明处理器当前的工作状态。用来指示处理器状态的寄存器，称为程序状态字。<br>比如 CF：进位标志，ZF：结果为零标志等</p></blockquote><table><thead><tr><th>31</th><th>…….</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>ZF</td><td>AF</td><td>PF</td><td>1</td><td>CF</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">程序状态字一般包括：</span><br><span class="line">CPU的工作状态代码：指名当前的工作状态是管态还是目态</span><br><span class="line">  条件码：反映指令执行后的结果特征，比如结果为0等</span><br><span class="line">  中断屏蔽码：指出是否允许中断</span><br></pre></td></tr></table></figure><h2 id="2、硬件部件"><a href="#2、硬件部件" class="headerlink" title="2、硬件部件"></a>2、硬件部件</h2><h3 id="①、存储系统"><a href="#①、存储系统" class="headerlink" title="①、存储系统"></a>①、存储系统</h3><h4 id="存储器的类型"><a href="#存储器的类型" class="headerlink" title="存储器的类型"></a>存储器的类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">类型</span><br><span class="line">读写型存储器（RAM），用来存储随机存取的程序和数据</span><br><span class="line">只读存储器（ROM），存放一些固化的程序</span><br><span class="line"></span><br><span class="line">存储分块</span><br><span class="line">存储的最小单位：位(bit)</span><br><span class="line">  最小编制单位：字节</span><br><span class="line">  分块：为了分配和管理方便，将内存划分为大相等的块（物理页Page），以块为单位分配内存空间，大小一般为512B,1KB,4KB,8KB等</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h4><blockquote><p>容量、速度和成本匹配</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/290620/1580545508494-28dec47e-75a0-4810-aeca-3fd67d91543e.jpeg#align=left&display=inline&height=445&margin=%5Bobject%20Object%5D&name=u%3D1432493203%2C1397722736%26fm%3D26%26gp%3D0.jpg&originHeight=445&originWidth=706&size=146044&status=done&style=none&width=706" alt="u=1432493203,1397722736&amp;fm=26&amp;gp=0.jpg"></p><blockquote><p>存储访问局部性原理</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">程序执行时，除了少部分的转移和过程调用指令外，在大多数情况下是顺序执行的</span><br><span class="line"></span><br><span class="line">过程调用将会使程序的执行轨迹，由一部分区域转至另一部分区域。即程序将会在一段时间内，都局部在这些过程的范围内运行</span><br><span class="line"></span><br><span class="line">程序中存在许多循环结构，这些虽然只由少数指令构成，但是它们将多次执行。</span><br><span class="line"></span><br><span class="line">程序中还包括许多对数据结构的处理，如对数组进行操作，它们往往都局限于很小的范围内。</span><br><span class="line"></span><br><span class="line">基于这一原理，设计多级存储的体系结构</span><br></pre></td></tr></table></figure><h4 id="存储器保护"><a href="#存储器保护" class="headerlink" title="存储器保护"></a>存储器保护</h4><blockquote><p>多道程序设计系统中，保证每个程序独立运行、互不干扰、称为存储器保护<br>方法：界地址寄存器</p></blockquote><h3 id="②、I-x2F-O-部件"><a href="#②、I-x2F-O-部件" class="headerlink" title="②、I&#x2F;O 部件"></a>②、I&#x2F;O 部件</h3><h4 id="I-x2F-O-结构"><a href="#I-x2F-O-结构" class="headerlink" title="I&#x2F;O 结构"></a>I&#x2F;O 结构</h4><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><h4 id="DMA-技术"><a href="#DMA-技术" class="headerlink" title="DMA 技术"></a>DMA 技术</h4><h4 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h4><h3 id="③、时钟部件"><a href="#③、时钟部件" class="headerlink" title="③、时钟部件"></a>③、时钟部件</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">发现死循环，防止机时的浪费</span><br><span class="line">分时系统中，时钟间隔实现事件片轮转执行</span><br><span class="line">实时系统中，按要求的时间间隔控制设备</span><br><span class="line">定时唤醒各种外部事件</span><br><span class="line">记录各种设备的使用时间和某外部事件发生的时间间隔</span><br><span class="line">记录用户和系统所需的绝对时间，即年、月、日</span><br></pre></td></tr></table></figure><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">硬件时钟和软件时钟</span><br><span class="line">用途分：绝对时钟和相对时钟</span><br></pre></td></tr></table></figure><h2 id="3、中断机制"><a href="#3、中断机制" class="headerlink" title="3、中断机制"></a>3、中断机制</h2><h3 id="①、中断与异常"><a href="#①、中断与异常" class="headerlink" title="①、中断与异常"></a>①、中断与异常</h3><h4 id="中断："><a href="#中断：" class="headerlink" title="中断："></a>中断：</h4><blockquote><p>指处理器对系统中或系统外发生的异步事件的响应</p></blockquote><h4 id="异步事件："><a href="#异步事件：" class="headerlink" title="异步事件："></a>异步事件：</h4><blockquote><p>指无一定时序关系的随机发生的事件，如外部设备完成了数据传输任务，某以实时控制设备出现异常情况等</p></blockquote><h4 id="中断源："><a href="#中断源：" class="headerlink" title="中断源："></a>中断源：</h4><blockquote><p>引起中断的事件称为中断事件或中断源</p></blockquote><h4 id="中断请求："><a href="#中断请求：" class="headerlink" title="中断请求："></a>中断请求：</h4><blockquote><p>中断源向处理器发出的请求信号</p></blockquote><h4 id="中断处理程序："><a href="#中断处理程序：" class="headerlink" title="中断处理程序："></a>中断处理程序：</h4><blockquote><p>处理中断事件的程序</p></blockquote><h4 id="断点："><a href="#断点：" class="headerlink" title="断点："></a>断点：</h4><blockquote><p>发生中断时正在执行的程序的暂停点</p></blockquote><h4 id="中断响应："><a href="#中断响应：" class="headerlink" title="中断响应："></a>中断响应：</h4><blockquote><p>处理器暂停当前程序转而处理中断的过程</p></blockquote><h4 id="中断返回："><a href="#中断返回：" class="headerlink" title="中断返回："></a>中断返回：</h4><blockquote><p>中断处理程序结束之后恢复原来程序的执行</p></blockquote><h4 id="中断向量表："><a href="#中断向量表：" class="headerlink" title="中断向量表："></a>中断向量表：</h4><blockquote><p>为了使得中断装置可以找到恰当的中断处理程序，专门设计了中断处理程序的入口地址映射表，又称中断向量表</p></blockquote><h4 id="异常："><a href="#异常：" class="headerlink" title="异常："></a>异常：</h4><blockquote><p>由正在执行的指令引发的中断</p></blockquote><h4 id="典型的中断："><a href="#典型的中断：" class="headerlink" title="典型的中断："></a>典型的中断：</h4><blockquote><p>时钟中断、输入输出中断、控制台中断、硬件故障中断</p></blockquote><h4 id="典型的异常："><a href="#典型的异常：" class="headerlink" title="典型的异常："></a>典型的异常：</h4><blockquote><p>程序性中断、访管指令异常</p></blockquote><h3 id="②、中断请求的接收"><a href="#②、中断请求的接收" class="headerlink" title="②、中断请求的接收"></a>②、中断请求的接收</h3><blockquote><p>中断系统如何接受中断源的中断请求，因机器而异。一般由中断逻辑线路和中断寄存器实现</p></blockquote><h3 id="③、中断响应"><a href="#③、中断响应" class="headerlink" title="③、中断响应"></a>③、中断响应</h3><blockquote><p>处理器的控制部件中以后中断信号扫码结构，它在每条指令执行周期内的最后时刻扫码中断寄存器，查看是否由中断信号到来。若无中断信号，处理器就继续执行下一条指令。若由中断到来，处理器接收由硬件中断装置发来的中断向量代号，准备中断处理工作。</p></blockquote><h4 id="中断请求响应过程"><a href="#中断请求响应过程" class="headerlink" title="中断请求响应过程"></a>中断请求响应过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">处理器接收中断信号</span><br><span class="line">保护现场</span><br><span class="line">分析中断向量</span><br><span class="line">将处理器的PC值置为中断程序的入口地址</span><br><span class="line">调用中断处理程序</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="④、中断处理"><a href="#④、中断处理" class="headerlink" title="④、中断处理"></a>④、中断处理</h3><blockquote><p>中断信号被接收和响应之后，进行中断处理，包括：检查 I&#x2F;O 相关的状态信息，操纵 I&#x2F;O 设备或者在设备和内存之间传送数据等。<br>中断处理结束后，中断返回，恢复系统上下文，原有程序继续运行。处理器状态也从管态恢复成目态。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">整个中断信号的接收、响应和处理过程，可归纳为以下步骤：</span><br><span class="line">接收和响应中断</span><br><span class="line">  保护中断断点现场</span><br><span class="line">  分析中断向量，调用中断处理程序</span><br><span class="line">  中断处理结束恢复现场，原有程序继续执行</span><br></pre></td></tr></table></figure><h3 id="⑤、几种典型中断的处理"><a href="#⑤、几种典型中断的处理" class="headerlink" title="⑤、几种典型中断的处理"></a>⑤、几种典型中断的处理</h3><p>自愿性：<br>I&#x2F;O 中断<br>时钟中断<br>硬件故障中断<br>程序性中断<br>强迫性：<br>系统服务请求</p><h2 id="4、中断优先级、中断屏蔽与中断嵌套"><a href="#4、中断优先级、中断屏蔽与中断嵌套" class="headerlink" title="4、中断优先级、中断屏蔽与中断嵌套"></a>4、中断优先级、中断屏蔽与中断嵌套</h2><h3 id="①、多级中断与中断优先级"><a href="#①、多级中断与中断优先级" class="headerlink" title="①、多级中断与中断优先级"></a>①、多级中断与中断优先级</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><blockquote><p>对各类中断信号依据其紧急程序和重要性划分级别，系统优先处理最紧急或最重要的任务<br>解决如果由多个中断信号同时到达，如何选择首个被处理的中断信号的问题</p></blockquote><h3 id="②、中断屏蔽"><a href="#②、中断屏蔽" class="headerlink" title="②、中断屏蔽"></a>②、中断屏蔽</h3><blockquote><p>整个中断系统中， 允许或者禁止中断系统对某些类别中断的响应。PSW 中设计有中断屏蔽位<br>比如：某个 I&#x2F;O 被中断屏蔽，意味着即使有 I&#x2F;O 中断信号，处理器也不响应<br>注意：有些信号是不能被屏蔽的。一般这些中断信号属于机器故障中断，比如断电，机器无法继续操作。一旦发生，无论信号是否被屏蔽，处理器都会立即响应，并进行处理。</p></blockquote><h3 id="③、中断嵌套"><a href="#③、中断嵌套" class="headerlink" title="③、中断嵌套"></a>③、中断嵌套</h3><blockquote><p>一般的计算机系统都有多个中断源，如果一个中断处理的过程中又发生了中断，有两种策略处理：<br>1、当处理一个中断时禁止其他中断<br>2、中断嵌套。即中断按照优先级划分，允许优先级高的中断优先级低的中断处理过程，优先进行处理。</p></blockquote><h2 id="5、系统调用"><a href="#5、系统调用" class="headerlink" title="5、系统调用"></a>5、系统调用</h2><blockquote><p>就是用户在程序中调用操作系统提供的一些子功能，是操作系统提供给编程人员的唯一接口<br>是一个中特殊的过程调用，由特殊的机器指令实现，这条指令将使系统转入管态</p></blockquote><h3 id="①、系统调用与函数调用的区别"><a href="#①、系统调用与函数调用的区别" class="headerlink" title="①、系统调用与函数调用的区别"></a>①、系统调用与函数调用的区别</h3><blockquote><p>运行在不同的状态<br>状态的转换<br>返回问题<br>嵌套调用</p></blockquote><h3 id="②、系统调用的分类"><a href="#②、系统调用的分类" class="headerlink" title="②、系统调用的分类"></a>②、系统调用的分类</h3><blockquote><p>进程控制类<br>文件操作类<br>进程通信类<br>设备管理类<br>信息维护类</p></blockquote><h3 id="③、系统调用与库函数、API、内核函数的关系"><a href="#③、系统调用与库函数、API、内核函数的关系" class="headerlink" title="③、系统调用与库函数、API、内核函数的关系"></a>③、系统调用与库函数、API、内核函数的关系</h3><h2 id="6、系统调用的处理过程"><a href="#6、系统调用的处理过程" class="headerlink" title="6、系统调用的处理过程"></a>6、系统调用的处理过程</h2><h4 id="陷入："><a href="#陷入：" class="headerlink" title="陷入："></a>陷入：</h4><blockquote><p>在系统中为控制系统调用服务的机构称为陷入或异常处理机构</p></blockquote><h4 id="陷入或异常指令（访管指令）"><a href="#陷入或异常指令（访管指令）" class="headerlink" title="陷入或异常指令（访管指令）"></a>陷入或异常指令（访管指令）</h4><blockquote><p>把由于系统调用引起处理器中断的指令称为陷入或异常指令（访管指令）</p></blockquote><h1 id="三、进程管理"><a href="#三、进程管理" class="headerlink" title="三、进程管理"></a>三、进程管理</h1><h2 id="1、多道程序设计"><a href="#1、多道程序设计" class="headerlink" title="1、多道程序设计"></a>1、多道程序设计</h2><h3 id="①、顺序程序设计"><a href="#①、顺序程序设计" class="headerlink" title="①、顺序程序设计"></a>①、顺序程序设计</h3><blockquote><p>程序是在一个时间上按照严格次序前后相继的操作序列<br>计算机也是以顺序方式工作的：计算机一次执行一条指令、对内存一次访问一个字节或字，对外部设备一次传送一个数据块等<br>我们把一个具有独立功能的程序独占处理器直到得到最终结果的过程称为程序的顺序执行</p></blockquote><h3 id="②、程序的顺序执行的特点"><a href="#②、程序的顺序执行的特点" class="headerlink" title="②、程序的顺序执行的特点"></a>②、程序的顺序执行的特点</h3><h4 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h4><p>程序所规定的动作在机器上严格地按照顺序执行</p><h4 id="封闭性"><a href="#封闭性" class="headerlink" title="封闭性"></a>封闭性</h4><p>程序运行后，其计算结果指取决于程序自身，程序执行得到的最终结果由给定的初始条件决定，不受外界因素影响。</p><h4 id="程序执行结果的确定性"><a href="#程序执行结果的确定性" class="headerlink" title="程序执行结果的确定性"></a>程序执行结果的确定性</h4><p>程序的执行的结果与其执行速度无关</p><h4 id="程序执行结果的可在现性"><a href="#程序执行结果的可在现性" class="headerlink" title="程序执行结果的可在现性"></a>程序执行结果的可在现性</h4><p>如果程序在不同的时间执行，只要初始体哦阿健相同，则结果就会相同。</p><h3 id="③、程序的并发性执行"><a href="#③、程序的并发性执行" class="headerlink" title="③、程序的并发性执行"></a>③、程序的并发性执行</h3><blockquote><p>所谓并发执行，是指两个或两个以上程序在计算机系统中，同时处于已开始执行且尚未结束的状态<br>能够参与并发执行的程序称为并发程序<br>并发程序的执行和程序顺序执行的特征不同</p></blockquote><h3 id="④、并发执行的特征"><a href="#④、并发执行的特征" class="headerlink" title="④、并发执行的特征"></a>④、并发执行的特征</h3><blockquote><p>在执行期间并发程序相互制约<br>程序与计算不再一一对应：<br>允许多个程序共享一个程序段<br>并发程序的执行结果不可再现：<br>并发程序与其执行的相对速度以及并发执行的多道程序之间的相互关系有关。<br>程序的并行执行和程序的并发执行<br>程序的并发执行是宏观上的同时，微观是顺序。并行则是微观上是同时的。</p></blockquote><h3 id="⑤、多道程序设计："><a href="#⑤、多道程序设计：" class="headerlink" title="⑤、多道程序设计："></a>⑤、多道程序设计：</h3><p>就是允许多个程序同时进入内存并运行。根本日暮是提高整个系统的效率。</p><h3 id="⑥、吞吐量："><a href="#⑥、吞吐量：" class="headerlink" title="⑥、吞吐量："></a>⑥、吞吐量：</h3><p>是指单位时间内系统所处理进程的道数，是衡量系统效率的尺度。</p><h3 id="⑦、特点："><a href="#⑦、特点：" class="headerlink" title="⑦、特点："></a>⑦、特点：</h3><p>独立性：在多道环境下执行的没到程序都是逻辑上独立的，且执行速度与其他程序无关，执行的起止时间也是独立的<br>随机性：程序和数据的输入与执行开始时间都是随机的<br>资源共享性：</p><h3 id="⑧、缺陷："><a href="#⑧、缺陷：" class="headerlink" title="⑧、缺陷："></a>⑧、缺陷：</h3><p>可能延长程序的执行时间<br>系统效率的提高由一定限度</p><h2 id="2、进程"><a href="#2、进程" class="headerlink" title="2、进程"></a>2、进程</h2><blockquote><p>进程是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。<br>分为：系统进程和用户进程</p></blockquote><h3 id="①、进程与程序的联系和区别"><a href="#①、进程与程序的联系和区别" class="headerlink" title="①、进程与程序的联系和区别"></a>①、进程与程序的联系和区别</h3><h4 id="联系："><a href="#联系：" class="headerlink" title="联系："></a>联系：</h4><p>程序是构成进程的组成部分之一，一个进程是运行目标是执行它所对应的程序。<br>进程&#x3D;程序+数据+进程控制块</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>程序是静态的，进程是动态的<br>二者是对多对的关系</p><h3 id="②、可再入程序"><a href="#②、可再入程序" class="headerlink" title="②、可再入程序"></a>②、可再入程序</h3><p>一个能够被多个用户同时调用的程序称作是“可再入”程序<br>可再入程序必须是纯代码，程序在执行过程中不会修改自己的代码，必须与数据区隔离。<br>比如：操作系统、编译程序，它们能同时被不同用户调用而形成不同的进程。</p><h3 id="③、进程的特征"><a href="#③、进程的特征" class="headerlink" title="③、进程的特征"></a>③、进程的特征</h3><p>并发性<br>动态性<br>独立性<br>交往性<br>异步性<br>结构性</p><h3 id="④、进程模型"><a href="#④、进程模型" class="headerlink" title="④、进程模型"></a>④、进程模型</h3><h4 id="三状态进程模型"><a href="#三状态进程模型" class="headerlink" title="三状态进程模型"></a>三状态进程模型</h4><p>运行状态<br>就绪状态<br>等待状态</p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>就绪&#x3D;》运行<br>运行&#x3D;》就绪<br>运行&#x3D;》等待<br>等待&#x3D;》就绪</p><h4 id="五状态进程模型"><a href="#五状态进程模型" class="headerlink" title="五状态进程模型"></a>五状态进程模型</h4><p>运行状态<br>就绪状态<br>阻塞状态<br>创建状态<br>结束状态</p><h4 id="七状态进程模型"><a href="#七状态进程模型" class="headerlink" title="七状态进程模型"></a>七状态进程模型</h4><h3 id="⑤、进程控制块"><a href="#⑤、进程控制块" class="headerlink" title="⑤、进程控制块"></a>⑤、进程控制块</h3><p>为了便于系统操控和描述进程的活动过程，在操作系统核心中定义了一个专门的数据结构，称为 PCB</p><h4 id="PCB-的作用："><a href="#PCB-的作用：" class="headerlink" title="PCB 的作用："></a>PCB 的作用：</h4><p>描述进程的基本情况以及进程的运行变化过程。<br>PCB 是进程存在的唯一标志，当系统创建一个进程时，为进程设置一个 PCB，再利用 PCB 对进程进行控制和管理。撤销进程时，系统收回 PCB，进程也随之消亡。</p><h4 id="PCB-的内容：调度信息"><a href="#PCB-的内容：调度信息" class="headerlink" title="PCB 的内容：调度信息"></a>PCB 的内容：调度信息</h4><p>供进程调度时使用，包括进程名、进程号、地址空间信息、优先级、当前状态、资源清单、“家族”关系、消息队列指针、进程队列指针和当前打开文件等。</p><h4 id="PCB-的内容：现场信息"><a href="#PCB-的内容：现场信息" class="headerlink" title="PCB 的内容：现场信息"></a>PCB 的内容：现场信息</h4><p>刻画了进程的运行情况，主要是 CPU 寄存器的信息，如程序状态字、时钟、界地址寄存器等。当程序中断时，需要保存现场信息。</p><h4 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h4><p>进程由程序、数据和进程控制块组成<br>PCB 是”灵魂”<br>程序和数据是”躯体”</p><h4 id="PCB-组织"><a href="#PCB-组织" class="headerlink" title="PCB 组织"></a>PCB 组织</h4><p>线性方式<br>索引方式<br>链接方式</p><h4 id="进程的队列"><a href="#进程的队列" class="headerlink" title="进程的队列"></a>进程的队列</h4><p>就绪队列（一个或多个）<br>等待队列（多个）<br>运行队列</p><h4 id="进程队列的组成"><a href="#进程队列的组成" class="headerlink" title="进程队列的组成"></a>进程队列的组成</h4><p>进程队列实际是 PCB 的链接。链接分为：单向链表和双向链表<br>出队：一个进程从所在队列退出<br>入队：一个进程排入到指定队列<br>插队：一个进程插入到某个进程队列的指定位置</p><h2 id="3、进程控制"><a href="#3、进程控制" class="headerlink" title="3、进程控制"></a>3、进程控制</h2><blockquote><p>对进程整个生命周期中各种状态之间的转换进行的控制。由原语实现。<br>原语：<br>就是由若干条指令组成，用于完成一定功能的一个过程，是一个不可分割的基本单位，即原语在执行过程中不想允许被中断。原子操作在系统态下执行，常驻内存</p></blockquote><h3 id="⑥、进程的控制原语"><a href="#⑥、进程的控制原语" class="headerlink" title="⑥、进程的控制原语"></a>⑥、进程的控制原语</h3><h4 id="创建原语"><a href="#创建原语" class="headerlink" title="创建原语"></a>创建原语</h4><blockquote><p>一个进程可以使用创建</p></blockquote><h4 id="撤销原语"><a href="#撤销原语" class="headerlink" title="撤销原语"></a>撤销原语</h4><h4 id="阻塞原语"><a href="#阻塞原语" class="headerlink" title="阻塞原语"></a>阻塞原语</h4><h4 id="唤醒原语"><a href="#唤醒原语" class="headerlink" title="唤醒原语"></a>唤醒原语</h4><h2 id="4、经典的进程同步问题"><a href="#4、经典的进程同步问题" class="headerlink" title="4、经典的进程同步问题"></a>4、经典的进程同步问题</h2><h3 id="①、简单生产者–消费者问题"><a href="#①、简单生产者–消费者问题" class="headerlink" title="①、简单生产者–消费者问题"></a>①、简单生产者–消费者问题</h3><blockquote><p>设有一个生产者进程 P，一个消费者进程 Q，他们通过一个缓冲区联系起来</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/290620/1581303206825-2ad169b4-7715-4595-bb33-a854c664b802.svg"></p><h4 id="二者关系描述："><a href="#二者关系描述：" class="headerlink" title="二者关系描述："></a>二者关系描述：</h4><p>生产者生产产品放入缓冲区，消费者从缓冲区取产品，进行消费<br>P 进程不能往已经”满”的缓冲区放产品，Q 进程不从”空”缓冲区中取产品</p><h4 id="信号量设置："><a href="#信号量设置：" class="headerlink" title="信号量设置："></a>信号量设置：</h4><p>empty: 初始设为 1，用于指示空缓冲区数量<br>full: 初始值为 0，用于指示满缓冲区数量</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">进程P：</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line">P(empty):</span><br><span class="line">  生产一个产品;</span><br><span class="line">  送产品到缓冲区;</span><br><span class="line">  V(full)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进程Q:</span><br><span class="line">whie(true) &#123;</span><br><span class="line">P(full);</span><br><span class="line">  从缓冲区取产品;</span><br><span class="line">  V(empty);</span><br><span class="line">  消费产品;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②、多个生产者-消费者问题"><a href="#②、多个生产者-消费者问题" class="headerlink" title="②、多个生产者-消费者问题"></a>②、多个生产者-消费者问题</h3><blockquote><p>设有若干个生产者 P1、P2、…若干个消费者 Q1、Q2…他们通过一个环形缓冲池联系起来</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581309753452-61213a34-0606-4843-a921-8ae99a2fb216.png#align=left&display=inline&height=264&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=350&size=9403&status=done&style=none&width=350" alt="image.png"></p><h4 id="同步问题和信号量设置"><a href="#同步问题和信号量设置" class="headerlink" title="同步问题和信号量设置"></a>同步问题和信号量设置</h4><p>生产者不能往满缓冲区中放产品，设置信号链 empty，初始值为 K，指示缓冲池中空缓冲区数目<br>消费者不能从空缓冲区中取产品，设置信号量 full，初始值为 0，指示缓冲池中的满缓冲区数目</p><h4 id="互斥问题和信号量设置："><a href="#互斥问题和信号量设置：" class="headerlink" title="互斥问题和信号量设置："></a>互斥问题和信号量设置：</h4><p>缓冲池必须互斥访问，设置信号链 mutex，初值为 1。</p><h4 id="其他变量设置"><a href="#其他变量设置" class="headerlink" title="其他变量设置"></a>其他变量设置</h4><p>整型量 i，j，初始值为 0，分别用于指示空缓冲区和满缓冲区的位置</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">进程P1,P2...</span><br><span class="line">i=0;</span><br><span class="line">while(true) &#123;</span><br><span class="line">生产产品;</span><br><span class="line">  P(empty);</span><br><span class="line">  P(mutex);</span><br><span class="line">  往buffer[i]中放产品;</span><br><span class="line">  i=(i+1) mod k;</span><br><span class="line">  V(mutex);</span><br><span class="line">  V(full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进程Q1、Q2...</span><br><span class="line">j=0;</span><br><span class="line">while(true) &#123;</span><br><span class="line">P(full);</span><br><span class="line">  P(mutex);</span><br><span class="line">  从buffer[j]取产品</span><br><span class="line">  j=(j+1) mod k;</span><br><span class="line">  V(mutex);</span><br><span class="line">  V(empty)；</span><br><span class="line">  消费产品;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、管程的提出"><a href="#5、管程的提出" class="headerlink" title="5、管程的提出"></a>5、管程的提出</h2><h3 id="①、信号量及-PV-操作的缺点"><a href="#①、信号量及-PV-操作的缺点" class="headerlink" title="①、信号量及 PV 操作的缺点"></a>①、信号量及 PV 操作的缺点</h3><p>程序易读性差<br>程序不利于修改和维护<br>正确性难以保证<br>为了更易于编写正确的程序，引入了管程</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><p>是一个由过程，变量及数据结果等组成的一个集合，它们组成一个特殊的模块或软件包。进程可在任何需要的时候调用管程中的过程。</p><h4 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h4><p>管程名称、共享数据说明、对数据进行操作的一组过程、对共享数据赋初值的语句</p><h3 id="②、进程通信"><a href="#②、进程通信" class="headerlink" title="②、进程通信"></a>②、进程通信</h3><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>在相互通信的进程之间，设又一个公共内存区，一组进程向该公共内存中写，另一组进程从公共内存中读，通过这种方式实现两组进程之间的信息交换。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581314886199-248b4942-e238-400a-a65e-5eb64ff02661.png#align=left&display=inline&height=472&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=282&size=12624&status=done&style=none&width=282" alt="image.png"></p><h3 id="③、消息机制-消息缓冲"><a href="#③、消息机制-消息缓冲" class="headerlink" title="③、消息机制-消息缓冲"></a>③、消息机制-消息缓冲</h3><h4 id="消息缓冲通信原理："><a href="#消息缓冲通信原理：" class="headerlink" title="消息缓冲通信原理："></a>消息缓冲通信原理：</h4><p>进程间的数据交换，是以格式化的消息（也称为报文）为单位的。程序员直接利用操作系统提供的一组通信命令（原语），实现大量数据的传递，通信过程对用户是透明的。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581315493259-3c315596-8fd6-42f1-94e5-52e33b863486.png#align=left&display=inline&height=610&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1125&size=38458&status=done&style=none&width=1125" alt="image.png"></p><h4 id="信箱通信原理："><a href="#信箱通信原理：" class="headerlink" title="信箱通信原理："></a>信箱通信原理：</h4><p>为了实现进程间的通信，可以设计一个通信机构–信箱，以发送信件和接收信件为进程间通信的基本方式。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581315782698-6991d45a-3785-4409-b933-4073f2440a26.png#align=left&display=inline&height=351&margin=%5Bobject%20Object%5D&name=image.png&originHeight=351&originWidth=979&size=21050&status=done&style=none&width=979" alt="image.png"></p><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><p>所谓”管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名 pipe 文件<br>最早出现在 UNIX 系统中，是 UNIX 系统进程通信的一大特色<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581316071561-aaff60cb-d3b3-460f-88a7-b570b511d8f6.png#align=left&display=inline&height=113&margin=%5Bobject%20Object%5D&name=image.png&originHeight=113&originWidth=625&size=5066&status=done&style=none&width=625" alt="image.png"></p><h2 id="6、死锁"><a href="#6、死锁" class="headerlink" title="6、死锁"></a>6、死锁</h2><h3 id="①、死锁产生"><a href="#①、死锁产生" class="headerlink" title="①、死锁产生"></a>①、死锁产生</h3><p>在多道程序系统中，同时又多个进程并发执行，共享系统资源，从而提高了系统资源利用率，提高了系统的处理能力。<br>但是，在进行资源分配时会产生一个随机性的错误–死锁。<br>在许多应用中，如实时控制和监视系统中，如果遇到死锁会带来很大的危害。</p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>指在多道程序系统中，一组进程中的每一个进程郡无限期地等待被该组进程中的另一个进程所占用且永远不会释放的资源。<br>处于死锁状态的进程称为死锁进程。</p><h4 id="资源的概念："><a href="#资源的概念：" class="headerlink" title="资源的概念："></a>资源的概念：</h4><p>永久性资源（可重用资源）：<br>如内存、外部设备、处理器等硬件资源。<br>各种数据文件、表格、共享程序代码等<br>临时性资源（消耗性资源）：<br>指由某个进程产生、只为另一个进程使用一次或经过短暂时间后便不再使用的资源。<br>如果 I&#x2F;O 和时钟中断信号、同步信号、消息等。</p><h4 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h4><p>竞争资源<br>系统在资源分配时出现失误、进程间对资源的相互争夺而造成僵局<br>进程推进顺序不合理</p><h4 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h4><p>对于永久性资源，产生死锁的四个必要条件<br>互斥条件<br>不可剥夺条件<br>请求和保持条件<br>循环等待条件</p><h4 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h4><p>预防死锁<br>避免死锁<br>检测与解除死锁<br>忽略死锁</p><h3 id="②、死锁预防"><a href="#②、死锁预防" class="headerlink" title="②、死锁预防"></a>②、死锁预防</h3><blockquote><p>是指在任何系统操作前（如分配资源、调度进程等），事先评估系统的可能情况，严格采取措施，使得产生死锁的四个必要条件不成立</p></blockquote><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>防患于未然</p><h4 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h4><p>破坏产生死锁的四个必要条件之一</p><h4 id="静态的资源分配策略"><a href="#静态的资源分配策略" class="headerlink" title="静态的资源分配策略"></a>静态的资源分配策略</h4><p>分配原则:<br>一个进程在申请新资源的要求得不到满足时，便处于等待状态，而处于等待状态的进程的全部资源可以被剥夺。<br>两个策略:<br>破坏不可剥夺条件<br>破坏请求和保持条件</p><h4 id="破坏不可剥夺条件："><a href="#破坏不可剥夺条件：" class="headerlink" title="破坏不可剥夺条件："></a>破坏不可剥夺条件：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两种方法：</span><br><span class="line">若一个进程已经占用了某些资源，又要申请新的资源，在得不到新资源的同时释放原有资源，然后等待。</span><br><span class="line">  若一个进程申请新资源，首先系统检测该资源是否可用，如果可用则分配。否则从其他等待进程剥夺资源分配给该进程，如果没有等待进程占有该资源，该进程必须等待，在等待过程中，资源也可能被剥夺。</span><br></pre></td></tr></table></figure><h4 id="破坏请求和保持条件："><a href="#破坏请求和保持条件：" class="headerlink" title="破坏请求和保持条件："></a>破坏请求和保持条件：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">每个进程必须在开始执行前就申请它所需要的全部资源，仅当前系统能满足进程的资源请求且把资源一次性分配给进程后，该进程才能开始执行。</span><br></pre></td></tr></table></figure><h4 id="资源的有序分配方法"><a href="#资源的有序分配方法" class="headerlink" title="资源的有序分配方法"></a>资源的有序分配方法</h4><p>策略：<br>破坏循环等待条件<br>方法：<br>对系统所有资源类型进行线性排序，</p><h3 id="③、死锁避免"><a href="#③、死锁避免" class="headerlink" title="③、死锁避免"></a>③、死锁避免</h3><h4 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h4><p>系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统不会发送死锁，则予与分配，否则，不予分配。</p><h4 id="和死锁预防的区别："><a href="#和死锁预防的区别：" class="headerlink" title="和死锁预防的区别："></a>和死锁预防的区别：</h4><p>死锁预防是破坏产生死锁的四个必要条件之一，严格地防止死锁的出现。而死锁避免是在系统运行过程中注意避免死锁的发送，即使死锁的必要条件存在，也不一定发送死锁。</p><h4 id="安全状态与安全序列："><a href="#安全状态与安全序列：" class="headerlink" title="安全状态与安全序列："></a>安全状态与安全序列：</h4><p>如果操作系统能保证所有的进程在有限时间内得到所需的全部资源，则称系统 处于“安全状态”，否则说系统是不安全的。<br>判断：如果存在一个由系统中所有及昵称构成的安全序列(P1,P2,…Pn)，则系统处于安全状态。</p><h4 id="安全状态与不安全状态的关系："><a href="#安全状态与不安全状态的关系：" class="headerlink" title="安全状态与不安全状态的关系："></a>安全状态与不安全状态的关系：</h4><p>系统中不存在安全序列，则称系统为不安全</p><h4 id="安全状态与不安全状态的关系：-1"><a href="#安全状态与不安全状态的关系：-1" class="headerlink" title="安全状态与不安全状态的关系："></a>安全状态与不安全状态的关系：</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581409081880-1403d646-f7da-4a87-b911-9b7c6d3a90ec.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image.png&originHeight=150&originWidth=440&size=6759&status=done&style=none&width=440" alt="image.png"></p><h4 id="银行家算法："><a href="#银行家算法：" class="headerlink" title="银行家算法："></a>银行家算法：</h4><p>原意:<br>确保银行在发放现金贷款时，不会发生不能满足所有客户需求的情况<br>操作系统:<br>保证系统不会进入不安全状态的算法</p><h3 id="④、死锁的检测与解除"><a href="#④、死锁的检测与解除" class="headerlink" title="④、死锁的检测与解除"></a>④、死锁的检测与解除</h3><p>假如系统为进程分配资源时，不采取任何限制性措施来避免和预防死锁，而是在操作系统运行过程中，不断地监督程序的执行和资源占用情况，判断是否为死锁，一旦发生死锁，采取专门的措施解除死锁，并以最小代价使系统恢复正常。</p><h4 id="死锁检测时机"><a href="#死锁检测时机" class="headerlink" title="死锁检测时机"></a>死锁检测时机</h4><p>检测的实质：<br>检测算法检测是否存在“循环等待”条件。<br>时机：<br>一次资源分配后<br>每次调度后<br>定时器定时运行检测程序<br>当某个进程长期处于阻塞状态或阻塞程序过多时</p><h4 id="解除死锁的方法"><a href="#解除死锁的方法" class="headerlink" title="解除死锁的方法"></a>解除死锁的方法</h4><p>剥夺资源<br>一旦死锁，挂起一些进程，剥夺它们占有的资源给死锁进程，以解除死锁<br>撤销进程<br>撤销部分死锁进程，将它们占有的资源分配给另一个死锁进程，直到死锁解除为止。<br>可以一次撤销所有死锁进程，也可以逐个撤销</p><h2 id="7、资源分配图"><a href="#7、资源分配图" class="headerlink" title="7、资源分配图"></a>7、资源分配图</h2><h3 id="①、资源分配图"><a href="#①、资源分配图" class="headerlink" title="①、资源分配图"></a>①、资源分配图</h3><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><p>描述系统中资源分配和申请情况，对死锁进程分析并采取对策</p><h4 id="SRAG-定义"><a href="#SRAG-定义" class="headerlink" title="SRAG 定义"></a>SRAG 定义</h4><p>是一张有向图，可定义为一个二元组，即，SRAG&#x3D;(V,E)，其中 V 是顶点的集合，包括进程集合、资源集合，E 是向边的集合，是一个有序对（Pi, ri）</p><p>, <img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581410738271-91417ae5-344c-42be-9bfe-49211e1a1a68.png#align=left&display=inline&height=258&margin=%5Bobject%20Object%5D&name=image.png&originHeight=258&originWidth=472&size=13959&status=done&style=none&width=472" alt="image.png"></p><h3 id="②、死锁定理"><a href="#②、死锁定理" class="headerlink" title="②、死锁定理"></a>②、死锁定理</h3><h4 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h4><p>判定死锁的法则</p><h4 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h4><p>如果资源分配图中没有环路，则系统无死锁。<br>如果资源分配图中出现了环路，则可能存在死锁。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581411040528-152a90bb-dc2a-46ca-841b-28ec0d9cc0ff.png#align=left&display=inline&height=361&margin=%5Bobject%20Object%5D&name=image.png&originHeight=361&originWidth=373&size=12762&status=done&style=none&width=373" alt="image.png"></p><h3 id="③、资源分配图简化方法"><a href="#③、资源分配图简化方法" class="headerlink" title="③、资源分配图简化方法"></a>③、资源分配图简化方法</h3><p>步骤：<br>在资源分配图中，找出一个既不阻塞又非独立的进程结点 Pi。在顺利的情况下，Pi 可获得所需资源而继续运行，直至运行完毕，再释放其所占有的全部资源，这相当于消去 Pi 的请求边和分配边，使之成为孤立的结点。<br>将 Pi 释放的资源分配给申请它的进程，若该进程能顺利运行完成，释放资源，再次成为孤立结点。<br>重复以上步，直至找不到符合条件的进程结点。<br>经过化简后，若能消去所有的边，则该图可完全简化，系统不存在死锁；否则不可完全简化，存在死锁。</p><h3 id="④、哲学家就餐问题"><a href="#④、哲学家就餐问题" class="headerlink" title="④、哲学家就餐问题"></a>④、哲学家就餐问题</h3><p>假设有 5 个哲学家，他们的生活只是思考和吃饭。这些哲学家共用一个圆桌，每位都有一把椅子。在桌子中央有一碗米饭，在桌子上放着 5 根筷子<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581421043610-dbedb0eb-93de-4f49-b1e9-f5ba328452ef.png#align=left&display=inline&height=346&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=408&size=35488&status=done&style=none&width=408" alt="image.png"></p><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1,1,1,1,1&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    P(chopstick[i]);// 拿左筷子</span><br><span class="line">    P(chopstick[(i+1) % 5]); // 拿右筷子</span><br><span class="line">    ...</span><br><span class="line">    eat;</span><br><span class="line">    ...</span><br><span class="line">    V(chopstick[i]); // 放左筷子</span><br><span class="line">    V(chopstick[(i+1) % 5]); // 放右筷子</span><br><span class="line">    ...</span><br><span class="line">    think;</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>死锁</p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>采用资源有序分配算法，给每个筷子编号，规定每个哲学家先拿编号小的筷子再拿编号大的筷子，哲学家 I（1&lt;&#x3D;i&lt;&#x3D;4）不变，第五个哲学家的程序改进如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1,1,1,1,1&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    P(chopstick[1]);// 拿右筷子</span><br><span class="line">    P(chopstick[5]); // 拿左筷子</span><br><span class="line">    ...</span><br><span class="line">    eat;</span><br><span class="line">    ...</span><br><span class="line">    V(chopstick[1]); // 放右筷子</span><br><span class="line">    V(chopstick[5]); // 放左筷子</span><br><span class="line">    ...</span><br><span class="line">    think;</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure><h1 id="四、存储管理"><a href="#四、存储管理" class="headerlink" title="四、存储管理"></a>四、存储管理</h1><h2 id="1、存储管理的任务"><a href="#1、存储管理的任务" class="headerlink" title="1、存储管理的任务"></a>1、存储管理的任务</h2><h3 id="①、内存管理"><a href="#①、内存管理" class="headerlink" title="①、内存管理"></a>①、内存管理</h3><h4 id="内存空间一般分为两个区域"><a href="#内存空间一般分为两个区域" class="headerlink" title="内存空间一般分为两个区域:"></a>内存空间一般分为两个区域:</h4><p>系统区：存放操作系统常驻内存部分，用户不能占用这部分空间<br>用户区：分配给用户使用，用于装入和存储用户程序和数据，随时变化。</p><h4 id="存储管理的实质："><a href="#存储管理的实质：" class="headerlink" title="存储管理的实质："></a>存储管理的实质：</h4><p>用户空间的管理</p><h4 id="内存管理问题主要包括"><a href="#内存管理问题主要包括" class="headerlink" title="内存管理问题主要包括"></a>内存管理问题主要包括</h4><p>内存管理方法<br>内存的分配与释放算法<br>虚拟存储器的管理<br>控制内存和外村之间的数据流动方法<br>地址变化技术<br>内存数据保护与共享技术</p><h3 id="②、内存的分配和回收"><a href="#②、内存的分配和回收" class="headerlink" title="②、内存的分配和回收"></a>②、内存的分配和回收</h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>记住每个存储区域的状态：空间与否<br>实施分配：用户提出请求，分配内存<br>回收：回收用户释放的区域</p><h4 id="内存分配表"><a href="#内存分配表" class="headerlink" title="内存分配表"></a>内存分配表</h4><p>位示图表示法<br>空闲页面法<br>空闲块表法</p><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><p>静态分配：程序运行前分配内存，不允许“搬家”<br>动态分配：程序运行时允许动态分配内存，且允许“搬家”</p><h4 id="存储共享"><a href="#存储共享" class="headerlink" title="存储共享"></a>存储共享</h4><p>所谓存储共享是指两个或多个进程公用内存中相同区域<br>包括：代码共享和数据共享<br>目的：节省内存空间，提高内存利用率‘通过内存共享实现进程通信</p><h4 id="存储保护："><a href="#存储保护：" class="headerlink" title="存储保护："></a>存储保护：</h4><p>目的：为多个程序共享内存提高保障，使在内存中的各道程序，只能访问它自己的区域，避免各道程序间相互干扰<br>方法：<br>地址越界保护<br>权限保护</p><h4 id="“扩充”内存容量"><a href="#“扩充”内存容量" class="headerlink" title="“扩充”内存容量"></a>“扩充”内存容量</h4><p>用户在编制程序时，不应该受内存容量的限制，所以要次啊用一定技术来“扩充”，内存的容量，使得用户得到比实际内存容量大得多的内存空间。<br>借助虚拟存储技术或交换技术完成，达到在逻辑上扩充内存容量的目的。</p><h3 id="③、地址转换"><a href="#③、地址转换" class="headerlink" title="③、地址转换"></a>③、地址转换</h3><h4 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a>地址重定位</h4><blockquote><p>当用户把程序装入内存时，存储管理为他分配的内存空间可能是从某一个单元开始的一组连续的地址空间，它的起始地址不固定，即逻辑地址与物理地址经常不一致<br>把逻辑地址转换为绝对地址的工作称为”地址重定位”，分为“静态重定位”和“动态重定位”两种</p></blockquote><h4 id="绝对地址："><a href="#绝对地址：" class="headerlink" title="绝对地址："></a>绝对地址：</h4><p>存储器以字节为单位编址，每个字节都有相应的地址，假定内存容量为 N，则编号顺序为 0，1，2，….N-1，该地址称为物理地址或绝对地址。</p><h4 id="物理地址空间"><a href="#物理地址空间" class="headerlink" title="物理地址空间"></a>物理地址空间</h4><p>由绝对地址对应的内存空间称为“物理地址空间”。</p><h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址:"></a>逻辑地址:</h4><p>在多道程序系统中，内存中同时存储了多个用户程序，每个用户不能预先知道他的程序被存储到了什么地方。为了方便，每个用户都可认为自己的程序和数据存储在一组“0”地址开始的连续空间中，用户程序用的地址，称为“逻辑地址”或“相对地址”。</p><h4 id="逻辑地址空间"><a href="#逻辑地址空间" class="headerlink" title="逻辑地址空间"></a>逻辑地址空间</h4><p>由逻辑地址对应的存储空间称为逻辑地址空间。</p><h4 id="静态重定位："><a href="#静态重定位：" class="headerlink" title="静态重定位："></a>静态重定位：</h4><p>内存在装入一个程序时，把程序中的指令和数据地址全部装换为绝对地址，该过程在程序运行前进程，程序运行过程中无需再转换</p><h4 id="动态重定位："><a href="#动态重定位：" class="headerlink" title="动态重定位："></a>动态重定位：</h4><p>内存在装入程序时，不进行地址转换，而是直接把程序装入到分配的内存中，程序在执行过程中完成地址转换</p><h2 id="2、分区管理方案"><a href="#2、分区管理方案" class="headerlink" title="2、分区管理方案"></a>2、分区管理方案</h2><h3 id="①、固定分区"><a href="#①、固定分区" class="headerlink" title="①、固定分区"></a>①、固定分区</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>多道程序环境下，整个用户空间划分为若干个固定大小的分区，每个分区中只装入一道作业，分区大小可以相同，也可以不同。</p><h4 id="内存分配表与分区的分配、回收"><a href="#内存分配表与分区的分配、回收" class="headerlink" title="内存分配表与分区的分配、回收"></a>内存分配表与分区的分配、回收</h4><p>内存分配表是一张分区说明表，记录分区号、分区大小、分区起始地址及使用状态等。<br>分配时按照进程的内存需求，按一定策略从分区表中找到空闲分区进行分配。<br>回收时，将内存分区登记在分区说明表中，并将其状态置为空闲状态。</p><h3 id="②、可变分区"><a href="#②、可变分区" class="headerlink" title="②、可变分区"></a>②、可变分区</h3><h4 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h4><p>系统不预先划分固定分区，而是在装入程序时划分内存分区，使为程序分配的内存区的大小正好等于程序的需求量，且分区的个数是可变的</p><h4 id="紧缩技术"><a href="#紧缩技术" class="headerlink" title="紧缩技术"></a>紧缩技术</h4><p>内存经过一段时间分配后，会存在很多很小的空间。<br>解决办法：紧缩</p><p>紧缩应注意的问题：<br>增加系统开销<br>移动是有条件的<br>比如进程正与设备交换信息，此时不能移动。<br>所以，采用紧缩技术时，应该尽可能减少需要移动的进程数和信息量</p><h4 id="可变分区的实现"><a href="#可变分区的实现" class="headerlink" title="可变分区的实现"></a>可变分区的实现</h4><p>硬件支持：<br>两个专用控制寄存器：基址寄存器和限长寄存器<br>绝对地址形成<br>程序装入内存后，分区的起始地址和长度装入两个寄存器，程序执行后，取出指令中的逻辑地址，绝对地址&#x3D;逻辑地址+基址寄存器内存<br>地址越界：<br>当逻辑地址&gt;限长寄存器值时，产生”地址越界”中断。<br>地址转换过程<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581426308841-badda089-8488-4c01-afa7-3ba94b14250e.png#align=left&display=inline&height=342&margin=%5Bobject%20Object%5D&name=image.png&originHeight=342&originWidth=835&size=17612&status=done&style=none&width=835" alt="image.png"><br>内存分配表：两个表格<br>已分配区表<br>未分配区表</p><h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><p>首次适应算法<br>思想：当接受到内存申请时，查找分区说明表，直到找到一个大小能满足要求的空闲分区为止，将其分割并分配。<br>优点：简单，可以快速做出分配决定<br>最优适应算法<br>思想：当接到内存申请时，查找分区说明表，找到一个大小能满足要求的最小空闲分区，将其分割并分配。<br>优点：节约空间<br>缺点：形成许多碎片<br>最坏适应算法<br>思想：当接到内存申请时，查找分区说明表直到找到一个大小能满足要求的最大空闲分区，将其分割并分配。<br>优点：碎片少<br>缺点：分割了大的空间，遇到较大申请，无法满足</p><h4 id="分区的回收："><a href="#分区的回收：" class="headerlink" title="分区的回收："></a>分区的回收：</h4><p>当用户程序执行结束后，系统回收已使用完毕的分区，将其记录在空闲区表中。假定归还的分区起始位置为 S，长度为 L。<br>考虑如下四种可能性：<br>回收区与插入点的上领空间分区 F1 相邻接。<br>回收分区与插入点的下邻空间 F2 相邻接<br>回收区同时与插入点的上、下两个空闲分区相邻接<br>回收区既不与 F1 邻接，又不与 F2 邻接<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581427236867-cfa1019c-cdd8-4dce-a21c-b0f016b3bfa9.png#align=left&display=inline&height=330&margin=%5Bobject%20Object%5D&name=image.png&originHeight=330&originWidth=827&size=21569&status=done&style=none&width=827" alt="image.png"></p><h4 id="分区的保护"><a href="#分区的保护" class="headerlink" title="分区的保护"></a>分区的保护</h4><p>两种方法：<br>系统设置界限寄存器，包括：上、下界寄存器或基址、限长寄存器<br>保护键方法</p><h4 id="分区管理方案的优缺点"><a href="#分区管理方案的优缺点" class="headerlink" title="分区管理方案的优缺点"></a>分区管理方案的优缺点</h4><p>优点：<br>简单、表格不多，实现起来容易，内存额外开销小，保护措施也简单。<br>在内存利用率方面可变化分区比固定分区高。<br>缺点：碎片多，不能为用户提供“虚存”，每个用户程序的存储受物理存储的限制。</p><h2 id="3、覆盖与交换技术"><a href="#3、覆盖与交换技术" class="headerlink" title="3、覆盖与交换技术"></a>3、覆盖与交换技术</h2><h3 id="①、覆盖技术"><a href="#①、覆盖技术" class="headerlink" title="①、覆盖技术"></a>①、覆盖技术</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>是指一个程序的若干程序段，或几个程序的某些部分共享某一个存储空间</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>把程序划分为若干功能上相对独立的程序段，按照其自身逻辑结构使那些不会同时执行的程序段共享同一块内存区域</p><h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><p>从用户级彻底解决内存小装不下程序的问题。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>打破了需要将一个程序的全部信息装入内存后程序才能运行的限制<br>在逻辑上扩充了内存空间，从而在某种程序上实现了在小容量内存上运行较大程序的功能</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>对用户不透明，增加了用户的负担。</p><h3 id="②、交换技术"><a href="#②、交换技术" class="headerlink" title="②、交换技术"></a>②、交换技术</h3><h4 id="交换的含义"><a href="#交换的含义" class="headerlink" title="交换的含义:"></a>交换的含义:</h4><p>进程从内存移到磁盘，并再移回内存</p><h4 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h4><p>分时系统和大多数现在操作系统，是虚拟内存系统的基础</p><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><p>换出进程的选择<br>交换时机的确定<br>交换空间的分配<br>换入进程换回内存时位置的确定</p><h2 id="4、虚拟页式存储管理方案"><a href="#4、虚拟页式存储管理方案" class="headerlink" title="4、虚拟页式存储管理方案"></a>4、虚拟页式存储管理方案</h2><h3 id="①、虚拟存储技术"><a href="#①、虚拟存储技术" class="headerlink" title="①、虚拟存储技术"></a>①、虚拟存储技术</h3><h4 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h4><p>利用大容量外存来扩充内存，产生一个比有限的实际内存空间大的多的、逻辑的虚拟内存空间，简称虚存。<br>采用二级存储器方式<br>是一种设计技巧，受外存容量的限制</p><h4 id="虚拟存储器需要硬件支持"><a href="#虚拟存储器需要硬件支持" class="headerlink" title="虚拟存储器需要硬件支持"></a>虚拟存储器需要硬件支持</h4><p>系统有容量足够大的外存<br>系统有一定容量的内存<br>实现虚-实转换的地址映射机制</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>程序部分装入内存便可运行，其他部分需要运行时再装入内存 （因为程序的局部性原理）</p><h4 id="与交换技术的区别"><a href="#与交换技术的区别" class="headerlink" title="与交换技术的区别"></a>与交换技术的区别</h4><p>交换技术交换单位是进程<br>虚拟内存以页为单位进程交换</p><h3 id="②、虚拟页式存储管理"><a href="#②、虚拟页式存储管理" class="headerlink" title="②、虚拟页式存储管理"></a>②、虚拟页式存储管理</h3><h4 id="物理页面和页面"><a href="#物理页面和页面" class="headerlink" title="物理页面和页面"></a>物理页面和页面</h4><p>物理页面：将内存分成大小相等的许多区，每个区称为一个“物理页面”。（物理块）<br>页面：将程序中的逻辑地址也进行分页，页的大小和物理页面大小一直。</p><h4 id="虚拟地址组成："><a href="#虚拟地址组成：" class="headerlink" title="虚拟地址组成："></a>虚拟地址组成：</h4><p>虚拟页号+页内地址</p><h3 id="③、物理内存的分配与回收"><a href="#③、物理内存的分配与回收" class="headerlink" title="③、物理内存的分配与回收"></a>③、物理内存的分配与回收</h3><h4 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h4><p>位示图中的每一位与物理块对应，其值为 0&#x2F;1，表示空闲&#x2F;占用。</p><h4 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h4><p>分配：在位示图中找出空闲物理页面数，如果能满足，则分配，并把相应位置为 1，计算物理页面号。<br>物理页面号&#x3D;字号*字长+位号<br>回收，当归还物理页面时，计算归还页面在位示图中对应的位置，将 1 改为 0.<br>字号&#x3D;[i&#x2F;字长]， 位号&#x3D;i mod 字长</p><h2 id="5、虚拟页式存储地址转换过程"><a href="#5、虚拟页式存储地址转换过程" class="headerlink" title="5、虚拟页式存储地址转换过程"></a>5、虚拟页式存储地址转换过程</h2><h3 id="①、页式存储管理的地址转换"><a href="#①、页式存储管理的地址转换" class="headerlink" title="①、页式存储管理的地址转换"></a>①、页式存储管理的地址转换</h3><h4 id="页表："><a href="#页表：" class="headerlink" title="页表："></a>页表：</h4><p>记录装入内存的逻辑页面与物理页面的对应关系<br>是硬件进行地址转换的依据<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581488009727-4abaa272-ddd7-4332-bae8-fcc9704c7f43.png#align=left&display=inline&height=466&margin=%5Bobject%20Object%5D&name=image.png&originHeight=466&originWidth=506&size=20378&status=done&style=none&width=506" alt="image.png"></p><h4 id="硬件支持："><a href="#硬件支持：" class="headerlink" title="硬件支持："></a>硬件支持：</h4><p>页表始址寄存器和页表长度寄存器，分别用存储正在运行程序的页表在内存的起始地址和页表的长度。</p><h4 id="地址转换过程："><a href="#地址转换过程：" class="headerlink" title="地址转换过程："></a>地址转换过程：</h4><p>在执行检索前，先将页号与页表长度进行比较，若页号大于或等于页表长度，则地址越界</p><h4 id="若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，则找到该表项在页表中的位置，找到该页的物理页号"><a href="#若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，则找到该表项在页表中的位置，找到该页的物理页号" class="headerlink" title="若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，则找到该表项在页表中的位置，找到该页的物理页号"></a>若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，则找到该表项在页表中的位置，找到该页的物理页号</h4><p>将有效地址的页内地址送入物理地址寄存器的块内地址字段中</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581488556959-243b6c40-a320-494c-9003-38132f06ec68.png#align=left&display=inline&height=308&margin=%5Bobject%20Object%5D&name=image.png&originHeight=308&originWidth=569&size=68635&status=done&style=none&width=569" alt="image.png"></p><h4 id="十进制计算"><a href="#十进制计算" class="headerlink" title="十进制计算"></a>十进制计算</h4><p>物理地址&#x3D;物理页面号*块长+页内地址</p><h4 id="二进制计算"><a href="#二进制计算" class="headerlink" title="二进制计算"></a>二进制计算</h4><p>物理页面好作为绝对地址的高位 地址，页内地址作为它的地址部分。</p><h4 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h4><p>物理页面号：页面在内存对应的物理页面号<br>有效位：页面是在内存还是在外村<br>访问位：页面是在内存中是否被访问过<br>修改位：页面在内存中是否被修改过<br>保护位：页面能否读&#x2F;写</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>多级页表<br>散列页表<br>反置页表</p><h4 id="转换检测缓冲区（TLB）"><a href="#转换检测缓冲区（TLB）" class="headerlink" title="转换检测缓冲区（TLB）"></a>转换检测缓冲区（TLB）</h4><p>高速缓存，也称为快表，登记了页表中的部分页号和物理页面的对应关系。</p><h3 id="②、缺页异常处理"><a href="#②、缺页异常处理" class="headerlink" title="②、缺页异常处理"></a>②、缺页异常处理</h3><h4 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h4><p>若在页表中发现所要访问的页面不在内存，则产生缺页异常</p><h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><p>查看有无空闲页面，若有，把要访问的页面调入内存；若无，选择一页换出内存，再把要访问的页面调入内存。</p><h3 id="③、页面调度策略"><a href="#③、页面调度策略" class="headerlink" title="③、页面调度策略"></a>③、页面调度策略</h3><h4 id="调入策略："><a href="#调入策略：" class="headerlink" title="调入策略："></a>调入策略：</h4><p>决定什么时候将一个页由外存调入内存。两种方法，请求调页和预调页。</p><h4 id="置页策略："><a href="#置页策略：" class="headerlink" title="置页策略："></a>置页策略：</h4><p>当产生缺页时，将所调入的页面置于何处。</p><h4 id="置换策略："><a href="#置换策略：" class="headerlink" title="置换策略："></a>置换策略：</h4><p>如果内存已满，确定哪个页面从内存中移出，为新的页面腾出空位。三种方法：固定分配局部置换、可变分配全局置换、可变分配局部置换。</p><h3 id="④、页面置换算法"><a href="#④、页面置换算法" class="headerlink" title="④、页面置换算法"></a>④、页面置换算法</h3><h4 id="“抖动”或”颠簸”："><a href="#“抖动”或”颠簸”：" class="headerlink" title="“抖动”或”颠簸”："></a>“抖动”或”颠簸”：</h4><p>刚被换出的页面又立即要用，把它装入内存后，不久又被换出，换出不久又被调入内存，如此反复，使调度非常频繁。</p><h4 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h4><p>OPT、FIFO、第二次机会页面置换算法、CLOCK、LRU 算法</p><h4 id="OPT–理想页面置换算法"><a href="#OPT–理想页面置换算法" class="headerlink" title="OPT–理想页面置换算法"></a>OPT–理想页面置换算法</h4><p>由 Belady 于 1966 年提出的一种理论上的算法。<br>其所选择的被淘汰页面，将是以后永不使用的，或是在最长（未来）时间内不再被访问的页面。<br>采用 OPT 算法，通常可保证获得最低的缺页率。</p><h1 id="五、文件系统"><a href="#五、文件系统" class="headerlink" title="五、文件系统"></a>五、文件系统</h1><h2 id="1、文件系统的任务"><a href="#1、文件系统的任务" class="headerlink" title="1、文件系统的任务"></a>1、文件系统的任务</h2><h3 id="①、文件的定义"><a href="#①、文件的定义" class="headerlink" title="①、文件的定义"></a>①、文件的定义</h3><h4 id="研究文件系统的两种观点："><a href="#研究文件系统的两种观点：" class="headerlink" title="研究文件系统的两种观点："></a>研究文件系统的两种观点：</h4><p>用户观点：关心文件由什么组成，如何命名，如何保护文件，可以进行任何操作。<br>系统观点：文件目录是怎样实现的，怎样管理存储空间，文件存储位置，磁盘实际运作方式及，存取速度，磁盘利用率等等。</p><h4 id="文件的定义："><a href="#文件的定义：" class="headerlink" title="文件的定义："></a>文件的定义：</h4><p>一组带标识的、在逻辑上有完整意义的信息项的序列。</p><h4 id="读写指针"><a href="#读写指针" class="headerlink" title="读写指针:"></a>读写指针:</h4><p>读指针用来记录文件当前的读取位置，写指针用来记录文件当前的写入位置。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>存储在磁盘，可长期保存。</p><h3 id="②、文件系统的定义"><a href="#②、文件系统的定义" class="headerlink" title="②、文件系统的定义"></a>②、文件系统的定义</h3><p>文件系统是操作系统中统一管理信息资源的一种软件。它管理文件的存储、检索、更新，提供更安全的共享和保护手段，并方便用户使用。</p><h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><p>统一管理文件的存储空间，实施存储空间的分配与回收<br>实现文件按名存取，以对用户透明的方式管理名字空间<br>实现文件信息的共享，并提供文件的共享和保密措施。<br>向用户提供一个方便使用的接口<br>系统维护及向用户提供有关信息<br>保持文件系统的执行效率<br>提供与 I&#x2F;O 的统一接口</p><h3 id="③、文件的存储介质及存取方式"><a href="#③、文件的存储介质及存取方式" class="headerlink" title="③、文件的存储介质及存取方式"></a>③、文件的存储介质及存取方式</h3><h4 id="外存储设备的特点"><a href="#外存储设备的特点" class="headerlink" title="外存储设备的特点"></a>外存储设备的特点</h4><p>特点：容量大、断电后仍可保存信息<br>组成：驱动部分和存储介质部分<br>种类：磁盘、磁带、磁鼓、纸带、光盘、闪存</p><h4 id="外存储设备的存储介质"><a href="#外存储设备的存储介质" class="headerlink" title="外存储设备的存储介质"></a>外存储设备的存储介质</h4><p>磁带<br>特点：容量大、存取速度慢、适合顺序存储<br>磁盘<br>分类：软盘和硬盘<br>特点：容量大、成本低、适合随机存储<br>磁盘的物理地址由柱面号、磁头号、扇区号组成<br>光盘<br>是利用在激光的作用下特性发送变化的一些材料制成的非磁性记录介质。<br>特点：容量大、速度快、价格便宜<br>闪存<br>特点：电擦除，随机存取、可靠性高、寿命长</p><h4 id="文件在存储设备中的存取方式"><a href="#文件在存储设备中的存取方式" class="headerlink" title="文件在存储设备中的存取方式"></a>文件在存储设备中的存取方式</h4><p>顺序存取：<br>按从前到后的次序依次访问文件的各个信息项<br>随机存取：<br>又称直接存取，允许用户按任意的次序、直接存取文件中的任意一个记录，或者根据存取命令把读写指针移到文件中的指定记录处读取。</p><h3 id="④、文件的分配"><a href="#④、文件的分配" class="headerlink" title="④、文件的分配"></a>④、文件的分配</h3><h4 id="按文件的用途分类"><a href="#按文件的用途分类" class="headerlink" title="按文件的用途分类"></a>按文件的用途分类</h4><p>系统文件<br>库函数文件<br>用户文件</p><h4 id="按文件的组织方式分类"><a href="#按文件的组织方式分类" class="headerlink" title="按文件的组织方式分类"></a>按文件的组织方式分类</h4><p>普通文件<br>目录文件<br>特殊文件</p><h4 id="一些常见的文件分类方式"><a href="#一些常见的文件分类方式" class="headerlink" title="一些常见的文件分类方式"></a>一些常见的文件分类方式</h4><p>按文件的保护方式：只读文件、读写文件、可执行文件、五保护文件<br>按信息的流向分：输入文件、输出文件、输入输出文件<br>按存放时限分：临时文件、永久文件、档案文件<br>按存储介质分：磁盘文件、磁带文件、卡片文件<br>按文件的组织结构分类：逻辑文件、物理文件</p><h2 id="2、文件的逻辑结构和物理结构"><a href="#2、文件的逻辑结构和物理结构" class="headerlink" title="2、文件的逻辑结构和物理结构"></a>2、文件的逻辑结构和物理结构</h2><blockquote><p>文件的逻辑结构<br>从用户观点出发所观察到的文件组织形式<br>文件的物理结构<br>又称为文件的存储结构，是指系统将文件存储在外存上所形成的一种存储组织形式，是用户看不见的</p></blockquote><h3 id="①、文件的逻辑结构"><a href="#①、文件的逻辑结构" class="headerlink" title="①、文件的逻辑结构"></a>①、文件的逻辑结构</h3><h4 id="设计文件逻辑结构的原则："><a href="#设计文件逻辑结构的原则：" class="headerlink" title="设计文件逻辑结构的原则："></a>设计文件逻辑结构的原则：</h4><p>易于操作<br>查找快捷<br>修改方便<br>空间紧凑</p><p>文件的逻辑机构<br>文件的逻辑结构所描述的信息是文件中信息的组织形式，可分为三类：<br>流式文件：有序字符的集合，基本单位是字符。源程序、目标代码等属于流式文件<br>记录式文件： 是一组有序记录的集合，基本单位是记录。又可分为定长记录文件和变长记录文件。</p><p>顺序结构<br>又称连续结构，它把逻辑上连续的文件信息依次存放在连续编号的物理块中。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581575551632-9786910d-978a-48a4-a5f4-de5e97cad43d.png#align=left&display=inline&height=255&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=539&size=9935&status=done&style=none&width=539" alt="image.png"></p><p>优点：<br>存取速度快，一旦知道了文件在存储设备上的起始块号和文件长度，便能快速进行存取。<br>支持顺序存放和随机存取<br>缺点：<br>文件不能动态增长<br>要求为一个文件分配连续的存储空间<br>不能灵活地删除和插入记录<br>出现碎片</p><p>链接结构<br>链接结构原理<br>将逻辑上连续的文件分散存储在若干个不连续的物理块中。<br>每个物理块中都设有一个指针，指向其后续的物理块。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581576173953-218716ed-aacf-4fca-a292-f66f1a497e9a.png#align=left&display=inline&height=346&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=698&size=16504&status=done&style=none&width=698" alt="image.png"></p><p>优点<br>解决了碎片问题，提供了磁盘空间利用率<br>文件可以动态扩充<br>缺点<br>存取速度慢，不适于随机存取<br>可靠性差</p><p>索引结构<br>索引结构原理<br>为每个文件分配一个索引块（表），把分配给该文件的所有盘块号，都记录在该索引块中<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581576402661-8c66e4b1-4318-49c2-9018-8f9ee4646d1c.png#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&name=image.png&originHeight=281&originWidth=653&size=63915&status=done&style=none&width=653" alt="image.png"><br>优点<br>文件动态增长<br>不要求为一个文件分配连续的存储空间<br>能灵活地删除和插入记录<br>能顺序存取和随机存取<br>缺点<br>引起较多的寻道次数和寻道时间<br>索引表本身增加了存储空间的开销</p><p>多级索引<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581576786328-7bdd0bfe-fcd4-46e1-a842-149381035d1f.png#align=left&display=inline&height=307&margin=%5Bobject%20Object%5D&name=image.png&originHeight=307&originWidth=343&size=20227&status=done&style=none&width=343" alt="image.png"></p><h2 id="3、文件目录"><a href="#3、文件目录" class="headerlink" title="3、文件目录"></a>3、文件目录</h2><h3 id="①、文件控制块"><a href="#①、文件控制块" class="headerlink" title="①、文件控制块"></a>①、文件控制块</h3><p>为文件设置的用于描述和控制文件的数据结构。文件管理程序可借助于文件控制块中的信息，对文件施以各种操作。</p><p>文件目录<br>文件控制块的游戏集合（文件于文件控制块一一对应）称为文件目录，一个文件控制块就是一个文件目录项。</p><p>文件控制块的内容<br>基本信息类：文件名、文件物理位置、文件逻辑结构、文件的物理结构。<br>存取控制信息类：文件主的存取权限、核准用户的存取权限以及一般用户的存取权限。<br>使用信息类：文件的建立日期和时间、文件上一次修改的日期和时间、当前已打开该文件的进程数、是否被其他进程锁住、文件在内存中是否已被修改但尚未拷贝到盘上等。</p><p>②、文件目录和当前目录<br>一级目录结构<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581817033766-7deb0d04-1681-4c24-9a31-578cfb716c25.png#align=left&display=inline&height=247&margin=%5Bobject%20Object%5D&name=image.png&originHeight=247&originWidth=446&size=12688&status=done&style=none&width=446" alt="image.png"><br>优点：简单且能实现目录管理的基本功能-按名存取<br>缺点：查询速度慢、不允许重名</p><p>二级目录结构<br>为了改变一级目录文件命名冲突，并提高对目录文件索引速度而将目录分为两级；<br>一级称为主文件目录，给出用户名，用户子目录所在的物理位置；<br>二级称为用户文件目录，给出该用户所有文件的 FCB</p><p>优点：解决了文件的重名问题和文件共享问题，提高搜索速度，查找时间降低<br>缺点：不太适合大量用户和大量文件的大系统，增加了系统开销。</p><p>多级目录<br>多级目录结构也称树形目录，产生于 unix 操作系统，已被现代操作系统广泛采用<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581817395366-2fc27302-640f-491d-b83e-bbed152750bb.png#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&name=image.png&originHeight=436&originWidth=514&size=19376&status=done&style=none&width=514" alt="image.png"><br>优点：层次结构清晰，便于管理和保护；有利于文件分类；解决重名问题；提高文件检索速度；能进行存取权限的控制。<br>缺点：查找一个文件按路径名逐层检查，由于每个文件都存放在外村，多次访盘影响速度</p><p>当前目录与目录检索<br>当前目录：当前正在使用的目录（也称工作目录或值班目录）<br>目录检索：用户访问文件时，需要进行目录检索，这时用户给出文件名，系统按名寻找目录项。<br>检索方法：全路径名（绝对路径名），相对路径</p><p>③、目录项和目录文件<br>目录项<br>一个文件控制块做成一个定长记录，这个记录称为目录项<br>目录文件<br>多个文件的文件控制块集中在一起组成了文件的目录。<br>文件目录以文件的形式保存，该文件称为目录文件。</p><p>④、目录项分解法<br>目的：<br>加快目录检索速度<br>分解：<br>目录项分解称两部分：符号目录项（次部）和基本目录下（主部）。<br>符号目录项：包含文件名和文件号<br>基本目录项：除文件名以外的 FCB 的其他全部信息。<br>优点：<br>减少磁盘的访问次数，提高文件目录检索速度<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581817993589-1af31203-eb23-42f6-b091-4d6725a659df.png#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=429&size=15104&status=done&style=none&width=429" alt="image.png"></p><p>⑤、UNIX 的文件目录结构<br>i 结点的引入<br>文件目录通常是存放在磁盘上的，可能要占用大量的盘块。在查找目录的过程中，需要多次启动磁盘。<br>UNIX 系统，采用了把文件名与文件描述信息分开的方法，亦即，使文件描述信息单独形成一个称为索引结点的数据结构，简称为 i 结点</p><p>i 结点的内容<br>文件主标识符、文件类型、文件存取权限、文件物理地址、文件长度、文件连接计数、文件存取时间等<br>物理结构<br>三级索引结构<br>目录查询</p><p>⑥、FAT 文件系统的实现<br>FAT 的含义：<br>文件分配表–File Allocation Table，最初为 DOS 系统设计，适合小容量磁盘，分配给文件的所有盘块号都放在该表中。<br>三个版本：<br>FAT-12、FAT-16、FAT-32</p><h2 id="4、文件存储空间"><a href="#4、文件存储空间" class="headerlink" title="4、文件存储空间"></a>4、文件存储空间</h2><p>①、磁盘空间管理<br>基本思想<br>对于磁盘空空感觉的分配和回收方法。</p><p>②、磁盘空间的分配与回收算法<br>位示图<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581818652092-9d77546c-de59-41d3-99d5-98045582b919.png#align=left&display=inline&height=209&margin=%5Bobject%20Object%5D&name=image.png&originHeight=209&originWidth=480&size=12219&status=done&style=none&width=480" alt="image.png"></p><p>空闲块表<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581818698228-3069ab7f-7a78-4922-9631-78744541f43a.png#align=left&display=inline&height=160&margin=%5Bobject%20Object%5D&name=image.png&originHeight=160&originWidth=273&size=3979&status=done&style=none&width=273" alt="image.png"></p><p>空闲块链<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581819155008-db0eb4cd-74ac-4f17-8e1c-a1cbf1f3cd49.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=1106&size=610468&status=done&style=none&width=1106" alt="image.png"></p><p>③、成组链接的含义<br>文件区中的所有空闲盘块，被分成若干个组，比如，将每 100 个盘块作为一组。<br>将每一组含有的盘块总数 N 和该组所有的盘块号，记入其前一组的第一个盘块中。这样，由各组的第一个盘块可链成一条链。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581819142631-8d2c6846-71b5-4294-9fa0-675a21da786f.png#align=left&display=inline&height=477&margin=%5Bobject%20Object%5D&name=image.png&originHeight=477&originWidth=815&size=281473&status=done&style=none&width=815" alt="image.png"><br>分配：<br>在空闲块链中，不足 100 块的组，通常放在内存专用块中，系统初始化时，先把专用块内容读取到内存中，需要分配时，就直接在内存中找到哪块是空闲的，然后进行分配，空闲块数减 1，如果这一组的第一个空闲块页要分配，在分配之前，先把其保存的下一组的空闲盘块号读入内存中，再分配出去，依次类推。</p><p>回收：<br>归还一个空闲盘块时，把要归还的块号登记在当前组中，空闲块数加 1，如果当前已满 100 块，则把这 100 组中，空闲块数加 1，如果当前组已满 100 块，则把这 100 个块号写到要归还的那块中，该块就称为新组的第一块。</p><p>优点:<br>分配和回收空闲块时均在内存中查找和修改，只有在一组空闲块分配完成或空闲的磁盘块构成一组时才需要启动磁盘读写，效率高，能快速找到大量空闲盘块的地址，UNIX 采取这种方案</p><h2 id="5、实现文件系统的表目"><a href="#5、实现文件系统的表目" class="headerlink" title="5、实现文件系统的表目"></a>5、实现文件系统的表目</h2><h3 id="①、系统打开文件表"><a href="#①、系统打开文件表" class="headerlink" title="①、系统打开文件表"></a>①、系统打开文件表</h3><p>专门用来保存已打开文件的文件控制块<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581819739452-7a849b7d-ff34-4b9f-a8fa-50a89aa8bd5c.png#align=left&display=inline&height=116&margin=%5Bobject%20Object%5D&name=image.png&originHeight=116&originWidth=510&size=7865&status=done&style=none&width=510" alt="image.png"><br>共享计数：记录有多少个进程同时打开该文件<br>修改标志：指文件控制块或 i 结点的内容是否被修改过，如果修改过，则关闭文件时要将文件控制块写回磁盘</p><h3 id="②、用户打开文件表"><a href="#②、用户打开文件表" class="headerlink" title="②、用户打开文件表"></a>②、用户打开文件表</h3><p>每个用户都有一个“用户打开文件表”，其位置记录在 PCB 中，以 UNIX 为例，内容如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581819895178-73b56d48-11a4-4336-9fc5-e55527bb1455.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&name=image.png&originHeight=118&originWidth=502&size=7864&status=done&style=none&width=502" alt="image.png"></p><p>6、文件及目录的操作<br>①、典型的文件操作<br>建立文件<br>打开文件<br>读文件<br>写文件<br>关闭文件<br>删除文件</p><p>②、典型的目录操作<br>以 UNIX 系统为例<br>创建目录 creat<br>打开目录 open<br>读目录 readdir<br>创建链接 link<br>删除链接 ulink<br>修改目录名 rename<br>关闭目录 closedir<br>删除目录 delete</p><p>7、文件系统的性能<br>①、磁盘高速缓存<br>基本思想：<br>系统在内存中保存一些磁盘块，这些磁盘块在逻辑上属于磁盘，内存的这一区域被称为块高速缓存。<br>运行时，系统检查所有的读请求，查看文件块是否在高速缓存，在，则读；不在，首先启动磁盘，将所需块读到高速缓存，再复制到其他内存区域。若高速缓存已满，按照淘汰算法，选择较少使用的磁盘块换出。<br>块高速缓存要定期写回磁盘，以保存对磁盘块的修改。</p><p>文件系统一致性问题：<br>如果在修改过的磁盘块写回磁盘之前，系统出现故障，则文件系统有可能回处于不一致状态。特别是一些未写回的块是 i 结点、目录块或包含空闲表的磁盘块时，问题尤为严重。这一问题称为文件系统一致性问题。<br>高速缓冲的典型应用：记录的成组</p><p>记录的成组<br>把若干个逻辑记录合成一组存储到一个物理块的工作，称为记录的成组。<br>每块中的逻辑记录个数称为快因子<br>实现原理：信息交换以块为单位，故成组需要使用内存缓冲区来完成。缓冲区的长度&#x3D;记录的长度*块因子<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581820936990-184b0657-55a6-4fb1-b721-3dcaba68a5d3.png#align=left&display=inline&height=234&margin=%5Bobject%20Object%5D&name=image.png&originHeight=234&originWidth=754&size=12472&status=done&style=none&width=754" alt="image.png"></p><p>记录的分解</p><blockquote><p>从一组记录中把一个逻辑记录分离出来的过程称为记录的分解。</p></blockquote><p>过程：当用户请求读某记录时，文件系统首先找到该记录所在的磁盘块的位置，然后把含有该记录的物理块全部读入内存缓冲区，从内存缓冲区分解出指定的记录，然后送到用户工作区。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/290620/1581821093136-12fb2edb-4535-42c1-b04c-ea6fd8c077c9.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=684&size=14425&status=done&style=none&width=684" alt="image.png"></p><p>成组优点：提高了磁盘利用率，减少了启动盘的次数，提高了系统工作效率<br>要考虑的效率：定长记录和不定长记录</p><p>2、RAID 技术（磁盘阵列技术）<br>RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，通常简称为磁盘阵列。<br>简单地说， RAID 是由多个独立的高性能磁盘驱动器组成的磁盘子系统，从而提供比单个磁盘更高的存储性能和数据冗余的技术。 RAID 是一类多磁盘管理技术，其向主机环境提供了成本适中、数据可靠性高的高性能存储</p><p>好处主要有以下三种：<br>通过把多个磁盘组织在一起作为一个逻辑卷提供磁盘跨越功能。<br>通过把数据分成多个数据块（Block）并行写入&#x2F;读出多个磁盘以提高访问磁盘的速度<br>通过镜像或校验操作提供容错能力</p><p>RAID 不断地发展和革新，在计算机存储领域得到了广泛的应用，从高端系统逐渐延伸到普通的中低端系统。 RAID 技术如此流行，源于其具有显著的特征和优势，基本可以满足大部分的数据存储需求。</p><p>6、文件共享保护与保密<br>①、文件共享<br>文件共享的概念<br>文件共享是指一个文件可以允许多个用户共同使用。<br>文件共享的分类<br>从共享时间段上看，共享文件有两种使用情况：<br>文件可以同时使用<br>文件不允许同时使用<br>三种共享方式<br>文件被多个用户使用，由存取权限抗旨<br>文件被多个用户使用，但分别用自己的读写指针<br>文件被多个用户使用，但共享读写指针</p><h1 id="六、设备管理"><a href="#六、设备管理" class="headerlink" title="六、设备管理"></a>六、设备管理</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript如何对几十上百G的大文件读写处理</title>
      <link href="/2020/01/07/yuque/JavaScript%E5%A6%82%E4%BD%95%E5%AF%B9%E5%87%A0%E5%8D%81%E4%B8%8A%E7%99%BEG%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%A4%84%E7%90%86/"/>
      <url>/2020/01/07/yuque/JavaScript%E5%A6%82%E4%BD%95%E5%AF%B9%E5%87%A0%E5%8D%81%E4%B8%8A%E7%99%BEG%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>对 MongoDB 导出的 Json 文本进行统计处理， 但导出的 Json 文本因为是不规则的 Json 形式，无法使用 Json.parse。但是又要对数据进行各种计算聚合，达到业务所需的结果。</p><h2 id="2、错误想法-❎"><a href="#2、错误想法-❎" class="headerlink" title="2、错误想法 ❎"></a>2、错误想法 ❎</h2><p>由于没有处理过大文件的经历，没想到导出来的 Json 文件竟然高达几十 G。<br>平时直接使用,fs.readFile， 读起文件来，直接崩溃。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="built_in">require</span>(<span class="string">&#x27;bluebird&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readFileAsync = <span class="title class_">Promise</span>.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="keyword">let</span> content = <span class="keyword">await</span> <span class="title function_">readFileAsync</span>(filePath, <span class="string">&#x27;utf8’);</span></span><br></pre></td></tr></table></figure><h2 id="3、着手学习-Stream-模块【流】"><a href="#3、着手学习-Stream-模块【流】" class="headerlink" title="3、着手学习 Stream 模块【流】"></a>3、着手学习 Stream 模块【流】</h2><blockquote><p>&#x2F;&#x2F; 引入 Node 文档解释<br>Node.js 中有四种基本流类型：</p><ul><li>Writable：可以向其中写入数据的流（例如 fs.createWriteStream()）。</li><li>Readable：可以从中读取数据的流（例如 fs.createReadStream()）。</li><li>Duplex：同时为 Readable 和的流 Writable（例如 net.Socket）。</li><li>Transform：Duplex 可以在写入和读取数据时修改或转换数据的流（例如 zlib.createDeflate()）。</li></ul><p>流可以是可读的，可写的，或两者兼有。所有流都是的实例 EventEmitter</p></blockquote><p>所以，流是什么，就如同水。<br>写入流就是像倒水，一点一点慢慢的倒入杯中，<br>读取流就是像喝水，一口一口的喝进肚子里。</p><h2 id="4、重写脚本-✅"><a href="#4、重写脚本-✅" class="headerlink" title="4、重写脚本 ✅"></a>4、重写脚本 ✅</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="built_in">require</span>(<span class="string">&quot;bluebird&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据处理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dataProcessing</span>(<span class="params">row</span>) &#123;</span><br><span class="line">  <span class="comment">// 业务处理</span></span><br><span class="line">  <span class="keyword">return</span> row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进度show</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">userCount, startTime</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> jindu = <span class="title class_">Math</span>.<span class="title function_">floor</span>((userCount / <span class="number">10000000</span>) * <span class="number">100</span> * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`总数量:10000000, 当前处理数量:<span class="subst">$&#123;userCount&#125;</span>, 进度百分比: <span class="subst">$&#123;jindu&#125;</span>%`</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (userCount === <span class="number">10000000</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> endTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`共用时：<span class="subst">$&#123;(endTime - startTime) / <span class="number">1000</span>&#125;</span>秒。`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写流文件处理</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">streamFileFunc</span> = (<span class="params">readFilePath, writeFilePath</span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始读写流&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> readStreamFile = fs.<span class="title function_">createReadStream</span>(readFilePath);</span><br><span class="line">    <span class="keyword">const</span> writeStreamFile = fs.<span class="title function_">createWriteStream</span>(writeFilePath, &#123;</span><br><span class="line">      <span class="attr">flags</span>: <span class="string">&quot;w&quot;</span>,</span><br><span class="line">      <span class="attr">encoding</span>: <span class="string">&quot;utf8&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    readStreamFile.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 暂停读取, 做业务处理</span></span><br><span class="line">      readStreamFile.<span class="title function_">pause</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对不规则Json文本， 读一段，切割一段</span></span><br><span class="line">      data += <span class="title class_">String</span>(chunk);</span><br><span class="line">      data = data.<span class="title function_">split</span>(<span class="string">&quot;&#125;&#125;,&quot;</span>);</span><br><span class="line">      <span class="comment">// 剩下末尾不完整的，留到下一次拼接</span></span><br><span class="line">      <span class="keyword">const</span> lastData = data.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">      data.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理成能使用，JSON.parse的格式</span></span><br><span class="line">        <span class="keyword">if</span> (v[<span class="number">0</span>] !== <span class="string">&quot;&#123;&quot;</span>) v = <span class="string">`&#123;<span class="subst">$&#123;v&#125;</span>`</span>;</span><br><span class="line">        v += <span class="string">&quot;&#125;&#125;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑处理</span></span><br><span class="line">        <span class="keyword">const</span> ret = <span class="title function_">dataProcessing</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(v));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 流-写入数据</span></span><br><span class="line">        writeStreamFile.<span class="title function_">write</span>(<span class="title class_">String</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(ret)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数，看进度</span></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">show</span>(i, startTime);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">      &#125;);</span><br><span class="line">      data = lastData; <span class="comment">// 末尾拼接</span></span><br><span class="line"></span><br><span class="line">      readStreamFile.<span class="title function_">resume</span>(); <span class="comment">// 恢复读取并触发data事件</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    readStreamFile.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;流文件读取完成.....&quot;</span>);</span><br><span class="line">      writeStreamFile.<span class="title function_">end</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    readStreamFile.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`read stream file err: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;);</span><br><span class="line">    writeStreamFile.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`write stream file err: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">readFilePath, writeDataPath</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fs.<span class="title function_">existsSync</span>(readFilePath)) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">streamFileFunc</span>(readFilePath, writeDataPath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;main catch err:&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line"><span class="title function_">main</span>(<span class="string">&quot;./xxx.json&quot;</span>, <span class="string">&quot;./data.json&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="5、参考教程："><a href="#5、参考教程：" class="headerlink" title="5、参考教程："></a>5、参考教程：</h2><p><a href="https://www.iteye.com/blog/justcoding-2307215">https://www.iteye.com/blog/justcoding-2307215</a><br><a href="https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_class_stream_writable">https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_class_stream_writable</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 与PHP urlencode的差异</title>
      <link href="/2019/11/18/yuque/Node.js%20%E4%B8%8EPHP%20urlencode%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
      <url>/2019/11/18/yuque/Node.js%20%E4%B8%8EPHP%20urlencode%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<h1 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景:"></a>1、背景:</h1><p>当前业务需要对接第三方接口，为了确保数据的准确性，添加了签名规则。<br>第三方那边说，中文要做 urlencode 处理。<br>php 语言的话，就是参数数组做 http_build_query( ) 处理，然后拼接 计算 md5。</p><p>我方才用的是 Node.js encodeURIComponent 进行去编码，发现签名始终通不过，<br>经过对比，是 urlencode 之后产生的结果有一丝丝的差异<br>比如空格的 urlencode:<br>php http_build_query( )&#x3D;&gt;  +<br>NodeencodeURIComponent&#x3D;&gt;  %20</p><h1 id="2、解决办法"><a href="#2、解决办法" class="headerlink" title="2、解决办法"></a>2、解决办法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">urlencode</span> = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  str = <span class="string">`<span class="subst">$&#123;str&#125;</span>`</span>.<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">encodeURIComponent</span>(str)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/!/g</span>, <span class="string">&quot;%21&quot;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/&#x27;/g</span>, <span class="string">&quot;%27&quot;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/\(/g</span>, <span class="string">&quot;%28&quot;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/\)/g</span>, <span class="string">&quot;%29&quot;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/\*/g</span>, <span class="string">&quot;%2A&quot;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/%20/g</span>, <span class="string">&quot;+&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JenkinsX问题汇总</title>
      <link href="/2019/05/07/yuque/JenkinsX%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2019/05/07/yuque/JenkinsX%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>1、secrets “jenkins” not found</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$: jx ns jx</span><br></pre></td></tr></table></figure><p>2、X Sorry, your reply was invalid: GET <a href="https://api.github.com/repos/xxx/jxtest01">https://api.github.com/repos/xxx/jxtest01</a>: 401 Bad credentials</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jx delete git token -n GitHub admin</span><br><span class="line">➜  ~ jx create git token -n GitHub szeager</span><br><span class="line">Please generate an API Token for github server GitHub</span><br><span class="line">Click this URL https://github.com/settings/tokens/new?scopes=repo,read:user,read:org,user:email,write:repo_hook,delete_repo</span><br><span class="line"></span><br><span class="line">Then COPY the token and enter in into the form below:</span><br><span class="line"></span><br><span class="line">? API Token: *****************************************</span><br><span class="line">Created user szeager API Token for Git server GitHub at https://github.com</span><br></pre></td></tr></table></figure><p><img src="/images/yuque/JenkinsX%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/1.png" alt="1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>K8s的使用笔记</title>
      <link href="/2019/04/18/yuque/K8s%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/18/yuque/K8s%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1、创建一个集群"><a href="#1、创建一个集群" class="headerlink" title="1、创建一个集群"></a>1、创建一个集群</h1><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><p>$&gt; minikube version<br>minikube version: v0.15.0-katacoda</p><h2 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h2><p>$&gt; minikube start<br><img src="/images/yuque/K8s%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/1.png" alt="1"></p><h2 id="查看版本-1"><a href="#查看版本-1" class="headerlink" title="查看版本"></a>查看版本</h2><p>$&gt; kubectl version<br>Client Version: version.Info{Major:”1”, Minor:”5”, GitVersion:”v1.5.2”, GitCommit:”08e09955<br>4f3c31f6e6f07b448ab3ed78d0520507”, GitTreeState:”clean”, BuildDate:”2017-01-12T04:57:25Z”,<br>GoVersion:”go1.7.4”, Compiler:”gc”, Platform:”linux&#x2F;amd64”}<br>Server Version: version.Info{Major:”1”, Minor:”5”, GitVersion:”v1.5.2”, GitCommit:”08e09955<br>4f3c31f6e6f07b448ab3ed78d0520507”, GitTreeState:”clean”, BuildDate:”1970-01-01T00:00:00Z”,<br>GoVersion:”go1.7.1”, Compiler:”gc”, Platform:”linux&#x2F;amd64”}</p><h2 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h2><p>$&gt; kubectl cluster-info<br><img src="/images/yuque/K8s%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/2.png" alt="2"></p><h2 id="获取可用的-node"><a href="#获取可用的-node" class="headerlink" title="获取可用的 node"></a>获取可用的 node</h2><p>$&gt; kubectl get nodes<br><img src="/images/yuque/K8s%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/3.png" alt="3"></p><h1 id="2、部署应用"><a href="#2、部署应用" class="headerlink" title="2、部署应用"></a>2、部署应用</h1><p>kubectl run kubernetes-bootcamp –image&#x3D;docker.io&#x2F;jocatalin&#x2F;kubernetes-bootcamp:v1 –port&#x3D;8080<br><img src="/images/yuque/K8s%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/4.png" alt="4"></p><p>查看当前 pods<br><img src="/images/yuque/K8s%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/5.png" alt="5"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>K8s + minikube + VirtualBox环境安装</title>
      <link href="/2019/04/17/yuque/K8s%20+%20minikube%20+%20VirtualBox%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2019/04/17/yuque/K8s%20+%20minikube%20+%20VirtualBox%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1、安装-brew"><a href="#1、安装-brew" class="headerlink" title="1、安装 brew"></a>1、安装 brew</h2><blockquote><p>brew  全称 Homebrew，是 Mac OSX 上的软件包管理工具，能在 Mac 中方便的安装软件或者卸载软件。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><h2 id="2、安装-kubectl"><a href="#2、安装-kubectl" class="headerlink" title="2、安装 kubectl"></a>2、安装 kubectl</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install kubectl</span><br></pre></td></tr></table></figure><p><img src="/images/yuque/K8s+minikube+VirtualBox%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/1.png" alt="1"></p><h2 id="3、安装-VirtualBox"><a href="#3、安装-VirtualBox" class="headerlink" title="3、安装 VirtualBox"></a>3、安装 VirtualBox</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install virtualbox</span><br></pre></td></tr></table></figure><h2 id="3、安装-minikube"><a href="#3、安装-minikube" class="headerlink" title="3、安装 minikube"></a>3、安装 minikube</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew cask install minikube</span><br><span class="line">或者 阿里云minikube源:</span><br><span class="line">curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.0.0/minikube-darwin-amd64 &amp;&amp; sudo chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/</span><br><span class="line"></span><br><span class="line">阿里云minikube源:  https://github.com/AliyunContainerService/minikube</span><br></pre></td></tr></table></figure><p><img src="/images/yuque/K8s+minikube+VirtualBox%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/2.png" alt="2"></p><h2 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动VirtualBox</span><br><span class="line"></span><br><span class="line">VirtualBox</span><br><span class="line"></span><br><span class="line">启动minikube</span><br><span class="line"></span><br><span class="line">minikube start</span><br><span class="line"></span><br><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure><p><img src="/images/yuque/K8s+minikube+VirtualBox%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/3.png" alt="3"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1、minikube-Unable-to-start-VM-Error-loading-existing-host"><a href="#1、minikube-Unable-to-start-VM-Error-loading-existing-host" class="headerlink" title="1、minikube Unable to start VM: Error loading existing host"></a>1、minikube Unable to start VM: Error loading existing host</h2><p>一开始使用 brew install minikube，去安装 minikube， 在 minikube start 时遇到了问题。</p><p><img src="/images/yuque/K8s+minikube+VirtualBox%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/4.png" alt="4"><br>minikube delete 删除现有虚机，什么的都不生效，<br>然后直接卸载当前的 minikube，并且删除 ~&#x2F;.minikube 目录缓存的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 卸载</span><br><span class="line">brew cask uninstall --force minikube</span><br><span class="line"></span><br><span class="line">// 删除缓存目录</span><br><span class="line">sudo rm -rf ~/.minikube</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云端写作、自动构建部署</title>
      <link href="/2019/03/18/yuque/%E4%BA%91%E7%AB%AF%E5%86%99%E4%BD%9C%E3%80%81%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/03/18/yuque/%E4%BA%91%E7%AB%AF%E5%86%99%E4%BD%9C%E3%80%81%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="技术点：Hexo-GitHub-Yuque-Serverless-Travis"><a href="#技术点：Hexo-GitHub-Yuque-Serverless-Travis" class="headerlink" title="技术点：Hexo+GitHub+Yuque+Serverless+Travis"></a>技术点：Hexo+GitHub+Yuque+Serverless+Travis</h1><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="1、注册一个-GitHub-账号"><a href="#1、注册一个-GitHub-账号" class="headerlink" title="1、注册一个 GitHub 账号"></a>1、注册一个 GitHub 账号</h3><p>① 自行配置好 ssh<br>② 安装 git 插件</p><h3 id="2、创建两个-profile"><a href="#2、创建两个-profile" class="headerlink" title="2、创建两个 profile"></a>2、创建两个 profile</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552896233600-5c6c62cb-372c-4b34-a745-693047210aea.png#align=left&display=inline&height=745&name=image.png&originHeight=745&originWidth=1682&size=115849&status=done&width=1682" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552895982633-2db7e964-19ed-4d44-90cf-ee6af5d4e653.png#align=left&display=inline&height=295&name=image.png&originHeight=295&originWidth=762&size=30357&status=done&width=762" alt="image.png"></p><blockquote><p>yourname.github.io &#x3D;&gt; 用于存放 hexo 部署的静态文件</p><p>yourname-blog-source-code &#x3D;&gt; 用于存放 hexo 源码</p></blockquote><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="1、新建存放-hexo-的文件夹"><a href="#1、新建存放-hexo-的文件夹" class="headerlink" title="1、新建存放 hexo 的文件夹"></a>1、新建存放 hexo 的文件夹</h3><h3 id="2、初始化-Hexo"><a href="#2、初始化-Hexo" class="headerlink" title="2、初始化 Hexo"></a>2、初始化 Hexo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552896778936-14bba49d-b7d5-48cb-be67-c1e6a5368662.png#align=left&display=inline&height=1008&name=image.png&originHeight=1008&originWidth=1920&size=203613&status=done&width=1920" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552896812130-8d1afaba-2f77-4a33-92fb-868498eb87d9.png#align=left&display=inline&height=1008&name=image.png&originHeight=1008&originWidth=1920&size=247790&status=done&width=1920" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552897018365-453acf9f-8a2d-4549-b3b6-9fe2ff490e6e.png#align=left&display=inline&height=964&name=image.png&originHeight=964&originWidth=1911&size=573030&status=done&width=1911" alt="image.png"></p><h3 id="3、部署到-GitHub"><a href="#3、部署到-GitHub" class="headerlink" title="3、部署到 GitHub"></a>3、部署到 GitHub</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552897865010-8361706c-ad78-4c23-96ff-3811952df51a.png#align=left&display=inline&height=1008&name=image.png&originHeight=1008&originWidth=1920&size=243122&status=done&width=1920" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git// 存放hexo部静态文件的路径</span><br><span class="line">  branch: master// 分支</span><br><span class="line"></span><br><span class="line">hexo d// 部署</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><h3 id="4、添加远程仓库到本地-（hexo-源码仓库）"><a href="#4、添加远程仓库到本地-（hexo-源码仓库）" class="headerlink" title="4、添加远程仓库到本地 （hexo 源码仓库）"></a>4、添加远程仓库到本地 （hexo 源码仓库）</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552898183745-684dab63-3924-40a1-af14-c8782d8d1458.png#align=left&display=inline&height=264&name=image.png&originHeight=264&originWidth=528&size=36781&status=done&width=528" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">源Url: 存放hexo源码的路径</span><br><span class="line">目标路径: 本地存放的位置</span><br><span class="line">名称: 文件夹名</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><h3 id="5、复制一份-Hexo-初始化数据到本地-Hexo-仓库（因为懒）"><a href="#5、复制一份-Hexo-初始化数据到本地-Hexo-仓库（因为懒）" class="headerlink" title="5、复制一份 Hexo 初始化数据到本地 Hexo 仓库（因为懒）"></a>5、复制一份 Hexo 初始化数据到本地 Hexo 仓库（因为懒）</h3><h2 id="语雀"><a href="#语雀" class="headerlink" title="语雀"></a>语雀</h2><h3 id="1、创建账号"><a href="#1、创建账号" class="headerlink" title="1、创建账号"></a>1、创建账号</h3><h3 id="2、创建知识库"><a href="#2、创建知识库" class="headerlink" title="2、创建知识库"></a>2、创建知识库</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552902972074-554aed22-e55d-4bf2-aa3d-8bcb92cc2016.png#align=left&display=inline&height=368&name=image.png&originHeight=368&originWidth=1140&size=130486&status=done&width=1140" alt="image.png"></p><h3 id="3、路径最后可填写的是-repo，自己填，开心就好"><a href="#3、路径最后可填写的是-repo，自己填，开心就好" class="headerlink" title="3、路径最后可填写的是 repo，自己填，开心就好"></a>3、路径最后可填写的是 repo，自己填，开心就好</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552903032934-9256c574-fcdc-4a97-b557-9b11a393d687.png#align=left&display=inline&height=506&name=image.png&originHeight=506&originWidth=1101&size=33772&status=done&width=1101" alt="image.png"></p><h2 id="Travis"><a href="#Travis" class="headerlink" title="Travis"></a>Travis</h2><h3 id="1、注册-Travis-账号，（也就是同步-GitHub-账号）"><a href="#1、注册-Travis-账号，（也就是同步-GitHub-账号）" class="headerlink" title="1、注册 Travis 账号，（也就是同步 GitHub 账号）"></a>1、注册 Travis 账号，（也就是同步 GitHub 账号）</h3><blockquote></blockquote><h3 id="Travis-最新地址：https-travis-ci-com"><a href="#Travis-最新地址：https-travis-ci-com" class="headerlink" title="Travis 最新地址：https://travis-ci.com"></a>Travis 最新地址：<a href="https://travis-ci.com/szeager/szeager-blog-source-code">https://travis-ci.com</a></h3><blockquote></blockquote><h3 id="https-travis-ci-org-x3D-gt-是旧官网"><a href="#https-travis-ci-org-x3D-gt-是旧官网" class="headerlink" title="https://travis-ci.org &#x3D;&gt; 是旧官网"></a><a href="https://travis-ci.org/">https://travis-ci.org</a> &#x3D;&gt; 是旧官网</h3><h3 id="2、仓库权限"><a href="#2、仓库权限" class="headerlink" title="2、仓库权限"></a>2、仓库权限</h3><blockquote><p>全部或者选择部分仓库</p><p>看个人啦，我选择手动选择部分仓库</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552899238843-2e5ced52-3ecb-46a3-822e-975f69c19292.png#align=left&display=inline&height=586&name=image.png&originHeight=586&originWidth=1299&size=78786&status=done&width=1299" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552899285339-eae90254-e2a7-4826-8863-0f6919318e0a.png#align=left&display=inline&height=899&name=image.png&originHeight=899&originWidth=1151&size=153369&status=done&width=1151" alt="image.png"></p><h3 id="3、GitHub-创建个人访问令牌"><a href="#3、GitHub-创建个人访问令牌" class="headerlink" title="3、GitHub 创建个人访问令牌"></a>3、GitHub 创建个人访问令牌</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552900602804-e94bdd88-9c39-49f0-b88e-11a7a8c984f1.png#align=left&display=inline&height=671&name=image.png&originHeight=671&originWidth=1654&size=116674&status=done&width=1654" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552900654190-80c2cf13-feac-4dd7-be2a-7e577cdcf131.png#align=left&display=inline&height=674&name=image.png&originHeight=674&originWidth=1169&size=96365&status=done&width=1169" alt="image.png"></p><h3 id="4、本地源码仓库添加配置文件"><a href="#4、本地源码仓库添加配置文件" class="headerlink" title="4、本地源码仓库添加配置文件"></a>4、本地源码仓库添加配置文件</h3><blockquote><p>创建.travis.yml 文件</p><p>生成 env.secure<br>&#x3D;&gt; 自行安装好 Ruby<br>&#x3D;&gt; gem sources –add <a href="https://gems.ruby-china.org/">https://gems.ruby-china.org/</a> –remove <a href="https://rubygems.org/">https://rubygems.org/</a><br>&#x3D;&gt; 安装  sudo gem install travis<br>&#x3D;&gt; travis encrypt ‘GH_TOKEN&#x3D;${这里填写刚刚让你创建的个人访问令牌}’ –add</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552900892240-f76b1388-f110-474c-9b7b-43faa0b75adf.png#align=left&display=inline&height=720&name=image.png&originHeight=720&originWidth=1378&size=66046&status=done&width=1378" alt="image.png"></p><h3 id="5、源码仓库-Travis-添加变量"><a href="#5、源码仓库-Travis-添加变量" class="headerlink" title="5、源码仓库 Travis 添加变量"></a>5、源码仓库 Travis 添加变量</h3><blockquote><p>EMAIL: GitHub 邮箱<br>NAME： GitHub 名<br>GH_TOKEN: 个人访问令牌</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552901317185-ccdd5d74-1ef5-453a-9802-f9346ea71eb0.png#align=left&display=inline&height=477&name=image.png&originHeight=477&originWidth=1186&size=64550&status=done&width=1186" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552901270666-f246e75e-5af6-43aa-8445-6e4b8ba7e01f.png#align=left&display=inline&height=441&name=image.png&originHeight=441&originWidth=1547&size=50907&status=done&width=1547" alt="image.png"></p><h3 id="6、安装语雀插件库、修改配置"><a href="#6、安装语雀插件库、修改配置" class="headerlink" title="6、安装语雀插件库、修改配置"></a>6、安装语雀插件库、修改配置</h3><h4 id="安装-npm-yuque-hexo"><a href="#安装-npm-yuque-hexo" class="headerlink" title="安装 npm yuque-hexo"></a>安装 npm yuque-hexo</h4><blockquote><p>npm i -save yuque-hexo</p></blockquote><h4 id="package-json-修改配置"><a href="#package-json-修改配置" class="headerlink" title="package.json 修改配置"></a>package.json 修改配置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;hexo-site&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;hexo&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;3.8.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;hexo&quot;</span>: <span class="string">&quot;^3.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-deployer-git&quot;</span>: <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-generator-archive&quot;</span>: <span class="string">&quot;^0.1.5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-generator-category&quot;</span>: <span class="string">&quot;^0.1.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-generator-index&quot;</span>: <span class="string">&quot;^0.2.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-generator-tag&quot;</span>: <span class="string">&quot;^0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-renderer-ejs&quot;</span>: <span class="string">&quot;^0.3.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-renderer-marked&quot;</span>: <span class="string">&quot;^0.3.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-renderer-stylus&quot;</span>: <span class="string">&quot;^0.3.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-server&quot;</span>: <span class="string">&quot;^0.3.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;yuque-hexo&quot;</span>: <span class="string">&quot;^1.4.2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;<span class="comment">// 增加</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span>: <span class="string">&quot;yuque-hexo sync&quot;</span>,</span><br><span class="line">    <span class="string">&quot;clean:yuque&quot;</span>: <span class="string">&quot;yuque-hexo clean&quot;</span>,</span><br><span class="line">    <span class="string">&quot;deploy&quot;</span>: <span class="string">&quot;npm run sync &amp;&amp; hexo clean &amp;&amp; hexo g -d&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;yuqueConfig&quot;</span>: &#123; <span class="comment">// 语雀配置</span></span><br><span class="line">    <span class="string">&quot;postPath&quot;</span>: <span class="string">&quot;source/_posts/yuque&quot;</span>,<span class="comment">// 路径</span></span><br><span class="line">    <span class="string">&quot;cachePath&quot;</span>: <span class="string">&quot;yuque.json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;adapter&quot;</span>: <span class="string">&quot;hexo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;concurrency&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;https://www.yuque.com/api/v2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;login&quot;</span>: <span class="string">&quot;szeager&quot;</span>,<span class="comment">// 你语雀账号的名</span></span><br><span class="line">    <span class="string">&quot;repo&quot;</span>: <span class="string">&quot;blog&quot;</span>,  <span class="comment">// 你在语雀设置的repo</span></span><br><span class="line">    <span class="string">&quot;mdNameFormat&quot;</span>: <span class="string">&quot;title&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、-Travis-yml-配置"><a href="#7、-Travis-yml-配置" class="headerlink" title="7、.Travis.yml 配置"></a>7、.Travis.yml 配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language</span>: node_js</span><br><span class="line"></span><br><span class="line"><span class="attr">node_js</span>:</span><br><span class="line">- <span class="string">&#x27;8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches</span>:</span><br><span class="line">  <span class="attr">only</span>:</span><br><span class="line">  - master</span><br><span class="line"></span><br><span class="line"><span class="attr">env</span>:</span><br><span class="line">  <span class="attr">global</span>:</span><br><span class="line">  - <span class="attr">GH_REF</span>: github.<span class="property">com</span>/yourname/yourname.<span class="property">github</span>.<span class="property">io</span>.<span class="property">git</span><span class="comment">// 存放hexo部静态文件的路径</span></span><br><span class="line">  - <span class="attr">secure</span>: mlgYyRz1J............. <span class="comment">// 刚才生成的secure</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install</span>:</span><br><span class="line">- <span class="keyword">export</span> <span class="variable constant_">TZ</span>=<span class="string">&#x27;Asia/Shanghai&#x27;</span><span class="comment">// 时区</span></span><br><span class="line">- npm install -g hexo</span><br><span class="line">- npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="attr">before_script</span>:</span><br><span class="line">- git config --<span class="variable language_">global</span> user.<span class="property">name</span> <span class="string">&quot;$&#123;NAME&#125;&quot;</span><span class="comment">// 引用刚才在travis里配置的变量</span></span><br><span class="line">- git config --<span class="variable language_">global</span> user.<span class="property">email</span> <span class="string">&quot;$&#123;EMAIL&#125;&quot;</span></span><br><span class="line">- sed -i<span class="string">&#x27;&#x27;</span> <span class="string">&quot;s~git@github.com:yourname/yourname.github.io.git~https://$&#123;GH_TOKEN&#125;:x-oauth-basic@github.com/yourname/yourname.github.io.git~&quot;</span>  _config.<span class="property">yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install</span>:</span><br><span class="line">- npm install</span><br><span class="line"></span><br><span class="line"><span class="attr">script</span>:</span><br><span class="line">- npm run deploy</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8、本地源码仓库推送到-GitHub-仓库上"><a href="#8、本地源码仓库推送到-GitHub-仓库上" class="headerlink" title="8、本地源码仓库推送到 GitHub 仓库上"></a>8、本地源码仓库推送到 GitHub 仓库上</h3><h3 id="9、Travis-Token"><a href="#9、Travis-Token" class="headerlink" title="9、Travis Token"></a>9、Travis Token</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552974948060-30f2ad68-ab0f-490f-87b8-19522b6bc22c.png#align=left&display=inline&height=798&name=image.png&originHeight=798&originWidth=1371&size=127739&status=done&width=1371" alt="image.png"></p><h3 id="10、获取-Travis-上的-repo-ID-hexo-源码仓库"><a href="#10、获取-Travis-上的-repo-ID-hexo-源码仓库" class="headerlink" title="10、获取 Travis 上的 repo ID (hexo 源码仓库)"></a>10、获取 Travis 上的 repo ID (hexo 源码仓库)</h3><blockquote><p>curl -H ‘Travis-API-Version:3’ -H ‘User-Agent: API Explorer’ \ -H ‘Authorization:token xxxxxxxx(Travis Token)’ \<a href="https://api.travis-ci.com/owner/yourname/repos">https://api.travis-ci.com/owner/yourname/repos</a></p><p>token 替换成自己的 Travis Token<br>yourname 替换成自己的名称</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552975340070-2ae65129-d7a9-46de-9b0f-17596a224601.png#align=left&display=inline&height=937&name=image.png&originHeight=937&originWidth=1904&size=142879&status=done&width=1904" alt="image.png"></p><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><h3 id="1、注册一个腾讯云账号（我直接用微信登录了，方便）"><a href="#1、注册一个腾讯云账号（我直接用微信登录了，方便）" class="headerlink" title="1、注册一个腾讯云账号（我直接用微信登录了，方便）"></a>1、注册一个腾讯云账号（我直接用微信登录了，方便）</h3><h3 id="2、开通-Serverless-服务（无服务器云函数）"><a href="#2、开通-Serverless-服务（无服务器云函数）" class="headerlink" title="2、开通 Serverless 服务（无服务器云函数）"></a>2、开通 Serverless 服务（无服务器云函数）</h3><h3 id="3、创建一个函数"><a href="#3、创建一个函数" class="headerlink" title="3、创建一个函数"></a>3、创建一个函数</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552974752567-fe40339c-5be9-45f9-89a1-9bdca10a062a.png#align=left&display=inline&height=549&name=image.png&originHeight=549&originWidth=1468&size=68600&status=done&width=1468" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552974780687-e062f320-8370-4afa-86ab-89f98f13e1de.png#align=left&display=inline&height=918&name=image.png&originHeight=918&originWidth=1906&size=195795&status=done&width=1906" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552974806262-14ec1314-4491-4476-9268-d9b9315c6cb9.png#align=left&display=inline&height=861&name=image.png&originHeight=861&originWidth=1715&size=139267&status=done&width=1715" alt="image.png"></p><h3 id="4、修改函数代码"><a href="#4、修改函数代码" class="headerlink" title="4、修改函数代码"></a>4、修改函数代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function main_handler($event, $context) &#123;</span><br><span class="line">    // 解析语雀post的数据</span><br><span class="line">    $update_title = &#x27;&#x27;;</span><br><span class="line">    if($event-&gt;body)&#123;</span><br><span class="line">        $yuque_data= json_decode($event-&gt;body);</span><br><span class="line">        $update_title .= $yuque_data-&gt;data-&gt;title;</span><br><span class="line">    &#125;</span><br><span class="line">    // default params</span><br><span class="line">    $repos = &#x27;8424033&#x27;;  // Travis 上的 repo ID</span><br><span class="line">    $token = &#x27;e_3IIOUy1OTI_iRcAbsZ7Q&#x27;; // 你的登录token</span><br><span class="line">    $message = date(&quot;Y/m/d&quot;).&#x27;:yuque update:&#x27;.$update_title;</span><br><span class="line">    $branch = &#x27;master&#x27;;</span><br><span class="line">    // post params</span><br><span class="line">    $queryString = $event-&gt;queryString;</span><br><span class="line">    $q_token = $queryString-&gt;token ? $queryString-&gt;token : $token;</span><br><span class="line">    $q_repos = $queryString-&gt;repos ? $queryString-&gt;repos : $repos;</span><br><span class="line">    $q_message = $queryString-&gt;message ? $queryString-&gt;message : $message;</span><br><span class="line">    $q_branch = $queryString-&gt;branch ? $queryString-&gt;branch : &#x27;master&#x27;;</span><br><span class="line">    echo($q_token);</span><br><span class="line">    echo(&#x27;===&#x27;);</span><br><span class="line">    echo ($q_repos);</span><br><span class="line">    echo (&#x27;===&#x27;);</span><br><span class="line">    echo ($q_message);</span><br><span class="line">    echo (&#x27;===&#x27;);</span><br><span class="line">    echo ($q_branch);</span><br><span class="line">    echo (&#x27;===&#x27;);</span><br><span class="line">    //request travis ci</span><br><span class="line">    $res_info = triggerTravisCI($q_repos, $q_token, $q_message, $q_branch);</span><br><span class="line"></span><br><span class="line">    $res_code = 0;</span><br><span class="line">    $res_message = &#x27;未知&#x27;;</span><br><span class="line">    if($res_info[&#x27;http_code&#x27;])&#123;</span><br><span class="line">        $res_code = $res_info[&#x27;http_code&#x27;];</span><br><span class="line">        switch($res_info[&#x27;http_code&#x27;])&#123;</span><br><span class="line">            case 200:</span><br><span class="line">            case 202:</span><br><span class="line">                $res_message = &#x27;success&#x27;;</span><br><span class="line">            break;</span><br><span class="line">            default:</span><br><span class="line">                $res_message = &#x27;faild&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $res = array(</span><br><span class="line">        &#x27;status&#x27;=&gt;$res_code,</span><br><span class="line">        &#x27;message&#x27;=&gt;$res_message</span><br><span class="line">    );</span><br><span class="line">    return $res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* @description  travis api , trigger a build</span><br><span class="line">* @param $repos string 仓库ID、slug</span><br><span class="line">* @param $token string 登录验证token</span><br><span class="line">* @param $message string 触发信息</span><br><span class="line">* @param $branch string 分支</span><br><span class="line">* @return $info array 回包信息</span><br><span class="line">*/</span><br><span class="line">function triggerTravisCI ($repos, $token, $message=&#x27;yuque update&#x27;, $branch=&#x27;master&#x27;) &#123;</span><br><span class="line">    //初始化</span><br><span class="line">    $curl = curl_init();</span><br><span class="line">    //设置抓取的url https://api.travis-ci.com/repo/******/requests</span><br><span class="line">    curl_setopt($curl, CURLOPT_URL, &#x27;https://api.travis-ci.com/repo/&#x27;.$repos.&#x27;/requests&#x27;);</span><br><span class="line">    //设置获取的信息以文件流的形式返回，而不是直接输出。</span><br><span class="line">    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">    //设置post方式提交</span><br><span class="line">    curl_setopt($curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);</span><br><span class="line">    //设置post数据</span><br><span class="line">    $post_data = json_encode(array(</span><br><span class="line">        &quot;request&quot;=&gt; array(</span><br><span class="line">            &quot;message&quot;=&gt;$message,</span><br><span class="line">            &quot;branch&quot;=&gt;$branch</span><br><span class="line">        )</span><br><span class="line">    ));</span><br><span class="line">    $header = array(</span><br><span class="line">      &#x27;Content-Type: application/json&#x27;,</span><br><span class="line">      &#x27;Travis-API-Version: 3&#x27;,</span><br><span class="line">      &#x27;Authorization:token &#x27;.$token,</span><br><span class="line">      &#x27;Content-Length:&#x27; . strlen($post_data)</span><br><span class="line">    );</span><br><span class="line">    curl_setopt($curl, CURLOPT_HTTPHEADER, $header);</span><br><span class="line">    curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data);</span><br><span class="line">    //执行命令</span><br><span class="line">    $data = curl_exec($curl);</span><br><span class="line">    $info = curl_getinfo($curl);</span><br><span class="line">    //关闭URL请求</span><br><span class="line">    curl_close($curl);</span><br><span class="line">    return $info;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="5、添加触发方式"><a href="#5、添加触发方式" class="headerlink" title="5、添加触发方式"></a>5、添加触发方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552975888467-4158eca1-da67-4465-90a1-ffb2d16eb87d.png#align=left&display=inline&height=695&name=image.png&originHeight=695&originWidth=1653&size=90302&status=done&width=1653" alt="image.png"></p><h3 id="6、复制触发链接，修改语雀配置"><a href="#6、复制触发链接，修改语雀配置" class="headerlink" title="6、复制触发链接，修改语雀配置"></a>6、复制触发链接，修改语雀配置</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552975923585-64f95f5b-beb6-42e3-96d4-474a6b5f3514.png#align=left&display=inline&height=559&name=image.png&originHeight=559&originWidth=1551&size=48050&status=done&width=1551" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552976027635-a3f59a1e-4992-4651-b293-5f713ac03ad1.png#align=left&display=inline&height=719&name=image.png&originHeight=719&originWidth=1535&size=86023&status=done&width=1535" alt="image.png"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><h3 id="1、在语雀你所创建的知识库里写一篇文章"><a href="#1、在语雀你所创建的知识库里写一篇文章" class="headerlink" title="1、在语雀你所创建的知识库里写一篇文章"></a>1、在语雀你所创建的知识库里写一篇文章</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552976232563-6dd4bb8e-0345-4e3b-9c0f-b1235c44af27.png#align=left&display=inline&height=962&name=image.png&originHeight=962&originWidth=1918&size=207210&status=done&width=1918" alt="image.png"></p><h3 id="2、Serverless-运行日志"><a href="#2、Serverless-运行日志" class="headerlink" title="2、Serverless 运行日志"></a>2、Serverless 运行日志</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552976928047-080e42e0-0081-41e6-a0ea-7c243e9465c8.png#align=left&display=inline&height=547&name=image.png&originHeight=547&originWidth=1913&size=114383&status=done&width=1913" alt="image.png"></p><h3 id="3、保存之后自动构建部署"><a href="#3、保存之后自动构建部署" class="headerlink" title="3、保存之后自动构建部署"></a>3、保存之后自动构建部署</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552976335224-2e0a2375-c229-434c-92f6-2de3d2b9a9ff.png#align=left&display=inline&height=877&name=image.png&originHeight=877&originWidth=1910&size=167606&status=done&width=1910" alt="image.png"></p><h3 id="4、完成，打开你的页面"><a href="#4、完成，打开你的页面" class="headerlink" title="4、完成，打开你的页面"></a>4、完成，打开你的页面</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/290620/1552976810531-6347c4b4-efc1-424d-beec-cf834bf1dcb3.png#align=left&display=inline&height=956&name=image.png&originHeight=956&originWidth=1917&size=610253&status=done&width=1917" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
